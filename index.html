<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Andy&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Andy&#39;s Blog">
<meta property="og:url" content="http://win120a.github.io/index.html">
<meta property="og:site_name" content="Andy&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Andy Cheung">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Andy's Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="/fonts/source-code-pro/latin.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Andy&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">-- 内核实验室</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://win120a.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-dubbo-eci-1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/19/dubbo-eci-1/" class="article-date">
  <time class="dt-published" datetime="2023-05-19T16:00:00.000Z" itemprop="datePublished">2023-05-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/05/19/dubbo-eci-1/">Dubbo 在 CI 中自动检查错误码 Logger 调用的实现（一） - 背景和错误码的获取</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>众所周知，Dubbo 在 3.1 版本中引入了错误码机制。在此摘抄一部分（我写的 &#x3D;_&#x3D; ）介绍文档如下 <sup>[1]</sup>：</p>
<blockquote>
<h3 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h3><p>Dubbo 内部依赖的 Logger 抽象层提供了日志输出能力，但是大部分的异常日志都没有附带排查说明，导致用户看到异常后无法进行处理。</p>
<p>为了解决这个问题，自 Dubbo 3.1 版本开始，引入了错误码机制。其将官方文档中的错误码 FAQ 与日志框架连接起来。在日志抽象输出异常的同时附带输出对应的官网文档链接，引导用户进行自主排查。</p>
<h3 id="错误码格式"><a href="#错误码格式" class="headerlink" title="错误码格式"></a>错误码格式</h3><p><code>[Cat]-[X]</code></p>
<p>两个空格均为数字。其中第一个数字为类别，第二个数字为具体错误码。</p>
<h3 id="Logger-接口支持"><a href="#Logger-接口支持" class="headerlink" title="Logger 接口支持"></a>Logger 接口支持</h3><p>为确保兼容性，Dubbo 3.1 基于原本的 Logger 抽象，构建了一个新的接口 <code>ErrorTypeAwareLogger</code>。</p>
<p>warn 等级的方法进行了扩展如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">warn</span><span class="params">(String code, String cause, String extendedInformation, String msg)</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">warn</span><span class="params">(String code, String cause, String extendedInformation, String msg, Throwable e)</span>;</span><br></pre></td></tr></table></figure>

<p>其中 code 指错误码，cause 指可能的原因（即 caused by… 后面所接的文字），extendedInformation 作为补充信息，直接附加在 caused by 这句话的后面。</p>
<p>（对于 error 级别也做了相同的扩展。）</p>
</blockquote>
<p>为了确保各位贡献者能够了解到错误码机制下的 Logger 调用的要求，需要在 CI 进行一些检查，具体如下：</p>
<ol>
<li>为了确保错误码机制在 Dubbo 项目中的覆盖，需要一个检测机制来确定对应的 Logger 是否正确调用。（即确定所有 error 和 warn 级别的 Logger 调用都是 <code>ErrorTypeAwareLogger</code> 的。但是 <code>ErrorTypeAwareLogger</code> 是派生于 <code>Logger</code> 类的，并且我们需要通过 Logger 接口的方法作为错误码 Logger 内部调用的基础。因此我们需要检查 warn 和 error 级别的日志方法中具体调用了哪个方法，是不是调用了本级方法而不是上级派生的日志方法？）</li>
<li>为了确保错误码对应的文档都存在，同样需要一个检测机制来确定对应的错误码的文档是否存在。</li>
</ol>
<p>这便是这次介绍的 Dubbo 错误码 Logger 调用检查器（Dubbo Error Code Inspector，还是我写的 &#x3D;_&#x3D;）的作用。我将会用几篇文章介绍下它的工作流程。</p>
<h1 id="错误码会出现在哪里"><a href="#错误码会出现在哪里" class="headerlink" title="错误码会出现在哪里"></a>错误码会出现在哪里</h1><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>为了确定所有错误码对应的文档都是存在的，我们需要拿到所有的错误码。</p>
<p>下面是错误码 Logger 调用的一些例子：</p>
<p>イ、org.apache.dubbo.common.DeprecatedMethodInvocationCounter <sup>[2]</sup>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Invoked by (modified) deprecated method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> methodDefinition filled by annotation processor. (like &#x27;org.apache.dubbo.common.URL.getServiceName()&#x27;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">onDeprecatedMethodCalled</span><span class="params">(String methodDefinition)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!hasThisMethodInvoked(methodDefinition)) &#123;</span><br><span class="line">        LOGGER.warn(</span><br><span class="line">            DeprecatedMethodInvocationCounterConstants.ERROR_CODE,</span><br><span class="line">            DeprecatedMethodInvocationCounterConstants.POSSIBLE_CAUSE,</span><br><span class="line">            DeprecatedMethodInvocationCounterConstants.EXTENDED_MESSAGE,</span><br><span class="line">            DeprecatedMethodInvocationCounterConstants.LOGGER_MESSAGE_PREFIX + methodDefinition</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    increaseInvocationCount(methodDefinition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应常量类 <code>org.apache.dubbo.common.constants.DeprecatedMethodInvocationCounterConstants</code> <sup>[3]</sup>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.dubbo.common.constants;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constants of Deprecated Method Invocation Counter.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">DeprecatedMethodInvocationCounterConstants</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">DeprecatedMethodInvocationCounterConstants</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;No instance of DeprecatedMethodInvocationCounterConstants for you! &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ERROR_CODE</span> <span class="operator">=</span> LoggerCodeConstants.COMMON_DEPRECATED_METHOD_INVOKED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">POSSIBLE_CAUSE</span> <span class="operator">=</span> <span class="string">&quot;invocation of deprecated method&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXTENDED_MESSAGE</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOGGER_MESSAGE_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;Deprecated method invoked. The method is &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>ロ、org.apache.dubbo.registry.support.CacheableFailbackRegistry <sup>[4]</sup>：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">evictURLCache</span><span class="params">(URL url)</span> &#123;</span><br><span class="line">    Map&lt;String, ServiceAddressURL&gt; oldURLs = stringUrls.remove(url);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// It seems that the most possible statement that causes exception is the &#x27;schedule()&#x27; method.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// The executor that FrameworkExecutorRepository.nextScheduledExecutor() method returns</span></span><br><span class="line">        <span class="comment">// is made by Executors.newSingleThreadScheduledExecutor().</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// After observing the code of ScheduledThreadPoolExecutor.delayedExecute,</span></span><br><span class="line">        <span class="comment">// it seems that it only throws RejectedExecutionException when the thread pool is shutdown.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// When? FrameworkExecutorRepository gets destroyed.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1-3: URL evicting failed.</span></span><br><span class="line">        logger.warn(REGISTRY_FAILED_URL_EVICTING, <span class="string">&quot;thread pool getting destroyed&quot;</span>, <span class="string">&quot;&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;Failed to evict url for &quot;</span> + url.getServiceKey(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ハ、org.apache.dubbo.registry.support.CacheableFailbackRegistry <sup>[5]</sup> （错误码还不归属于常量管理的时候的 ロ 的代码段）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">evictURLCache</span><span class="params">(URL url)</span> &#123;</span><br><span class="line">    Map&lt;String, ServiceAddressURL&gt; oldURLs = stringUrls.remove(url);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1-3: URL evicting failed.</span></span><br><span class="line">        logger.warn(<span class="string">&quot;1-3&quot;</span>, <span class="string">&quot;thread pool getting destroyed&quot;</span>, <span class="string">&quot;&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;Failed to evict url for &quot;</span> + url.getServiceKey(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，错误码可能是直接量，也有可能在另一个常量文件里头（<code>org.apache.dubbo.common.constants.LoggerCodeConstants</code>）…… 理论上我们需要确定哪个是错误码的引用，然后到对应的常量文件去查询这个引用的错误码。</p>
<h2 id="Java-编译器对常量所作的优化"><a href="#Java-编译器对常量所作的优化" class="headerlink" title="Java 编译器对常量所作的优化"></a>Java 编译器对常量所作的优化</h2><p>听上去似乎挺复杂？其实不然，Java 编译器在遇到访问基本数据类型和 String 类型的常量（即用 <code>static final</code> 修饰）的时候，它会把这个值直接传过去。</p>
<p>例如将上述 イ 号例子（第一个 <code>onDeprecatedMethodCalled</code> 的例子）编译出来，再用 Java Decompiler 反编译后的效果：</p>
<p><img src="/2023/05/19/dubbo-eci-1/java-decomplier.png" alt="Decompiled result of Dubbo Annotation Processor (R5.05.22-1)"></p>
<p>可以看见，常量引用消失了，原来常量的引用的地方变成了常量的本身的值。</p>
<p>于是乎，我们并不用翻来覆去地找对应的错误码的常量文件了，只用确定这个文件的常量中哪个是错误码就行了。</p>
<h2 id="class-文件中常量在哪里？"><a href="#class-文件中常量在哪里？" class="headerlink" title="class 文件中常量在哪里？"></a>class 文件中常量在哪里？</h2><p>参考 <a href="/2021/01/27/what-happened-on-annotations/">我此前介绍注解处理的文章</a> 可知，我们可以用 javap 工具确定 class 文件的结构。对于上述的 イ 号例子（第一个 <code>onDeprecatedMethodCalled</code> 的例子），对其进行 javap 分析如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">org</span>.apache.dubbo.common.DeprecatedMethodInvocationCounter</span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: (<span class="number">0x0031</span>) ACC_PUBLIC, ACC_FINAL, ACC_SUPER</span><br><span class="line">  this_class: #<span class="number">41</span>                         <span class="comment">// org/apache/dubbo/common/DeprecatedMethodInvocationCounter</span></span><br><span class="line">  super_class: #<span class="number">43</span>                        <span class="comment">// java/lang/Object</span></span><br><span class="line">  interfaces: <span class="number">0</span>, fields: <span class="number">2</span>, methods: <span class="number">7</span>, attributes: <span class="number">3</span></span><br><span class="line">Constant pool:</span><br><span class="line">    #<span class="number">1</span> = Methodref          #<span class="number">43.</span>#<span class="number">88</span>       <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">    #<span class="number">2</span> = Class              #<span class="number">89</span>           <span class="comment">// java/lang/UnsupportedOperationException</span></span><br><span class="line">    #<span class="number">3</span> = String             #<span class="number">90</span>           <span class="comment">// No instance of DeprecatedMethodInvocationCounter for you!</span></span><br><span class="line">    #<span class="number">4</span> = Methodref          #<span class="number">2.</span>#<span class="number">91</span>        <span class="comment">// java/lang/UnsupportedOperationException.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span></span><br><span class="line">    #<span class="number">5</span> = Methodref          #<span class="number">41.</span>#<span class="number">92</span>       <span class="comment">// org/apache/dubbo/common/DeprecatedMethodInvocationCounter.hasThisMethodInvoked:(Ljava/lang/String;)Z</span></span><br><span class="line">    #<span class="number">6</span> = Fieldref           #<span class="number">41.</span>#<span class="number">93</span>       <span class="comment">// org/apache/dubbo/common/DeprecatedMethodInvocationCounter.LOGGER:Lorg/apache/dubbo/common/logger/ErrorTypeAwareLogger;</span></span><br><span class="line">    #<span class="number">7</span> = Class              #<span class="number">94</span>           <span class="comment">// org/apache/dubbo/common/constants/DeprecatedMethodInvocationCounterConstants</span></span><br><span class="line">    #<span class="number">8</span> = String             #<span class="number">95</span>           <span class="comment">// 0-99</span></span><br><span class="line">    #<span class="number">9</span> = String             #<span class="number">96</span>           <span class="comment">// invocation of deprecated method</span></span><br><span class="line">   #<span class="number">10</span> = String             #<span class="number">97</span>           <span class="comment">//</span></span><br><span class="line">   #<span class="number">11</span> = Class              #<span class="number">98</span>           <span class="comment">// java/lang/StringBuilder</span></span><br><span class="line">   #<span class="number">12</span> = Methodref          #<span class="number">11.</span>#<span class="number">88</span>       <span class="comment">// java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>可以看见 #8 号常量就是我们所需要的错误码。</p>
<h1 id="怎么通过-Java-提取出错误码？"><a href="#怎么通过-Java-提取出错误码？" class="headerlink" title="怎么通过 Java 提取出错误码？"></a>怎么通过 Java 提取出错误码？</h1><p>Javassist 提供了操作 .class 文件的能力<sup>[6]</sup>。考虑到我们是直接读取 .class 文件中的常量池，所以使用 <code>ClassFile</code> 正合适。</p>
<h2 id="打开-class-文件"><a href="#打开-class-文件" class="headerlink" title="打开 .class 文件"></a>打开 .class 文件</h2><p>我们可以知道通过 Javassist 的 ClassFile 类可以操作 .class 文件，下面是用它打开 .class 文件的代码的一个例子 <sup>[7]</sup>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ClassFile <span class="title function_">openClassFile</span><span class="params">(String classFilePath)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] clsB = FileUtils.openFileAsByteArray(classFilePath);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ClassFile</span>(<span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(clsB)));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="获取常量池中的错误码"><a href="#获取常量池中的错误码" class="headerlink" title="获取常量池中的错误码"></a>获取常量池中的错误码</h2><p>据 .class 文件的结构，所有的 “常量” 都存在常量池中。所以考虑在 Javassist 中拿到 ConstPool，即调用 <code>ClassFile.getConstPool()</code> 方法 <sup>[8]</sup>，这样的话我们可以使用它来获取常量池的值。</p>
<p>根据上面对 .class 文件的分析，可以知道其在常量池的 #8 号位置，并且它是 String 类型，所以调用 <code>ConstPool.getStringInfo(int)</code> （其中 int 参数为 index，即常量池的索引） 可以获取对应 String 的内容。 </p>
<p>但是，因为我们获取的是多个的 class 文件的错误码，所以我们不能直接 “固定” 一个索引去拿错误码。考虑到 Javassist 的 API 是没法直接通过除了索引以外的数据来获取的。所以我们需要通过其它方式确认一个 .class 文件中所有的错误码。</p>
<h2 id="Javassist-的内部实现"><a href="#Javassist-的内部实现" class="headerlink" title="Javassist 的内部实现"></a>Javassist 的内部实现</h2><p>我们可以仔细看下 Javassist 的有关获取 String 信息的代码：</p>
<p><img src="/2023/05/19/dubbo-eci-1/javassist-code-r5-26-1.png" alt="Internals of Javassist #1, (R5.5.26-1)"></p>
<p>可以知道它们全部都调用了一个通用方法 <code>getItem()</code> ，如下 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ConstInfo <span class="title function_">getItem</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> items.elementAt(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合上述分析，我们可以知道 StringInfo 和 Utf8Info 都是 ConstInfo 的子类。对此我们可以先获取所有的常量池信息，然后筛选出合适的类型。</p>
<p>不论是 ConstInfo 还是 getItem 方法，都是包私有的，我们无法直接访问它。因此需要用到反射。</p>
<h2 id="确定单个-class-文件中所有的错误码"><a href="#确定单个-class-文件中所有的错误码" class="headerlink" title="确定单个 .class 文件中所有的错误码"></a>确定单个 .class 文件中所有的错误码</h2><h3 id="获取所有的常量池信息"><a href="#获取所有的常量池信息" class="headerlink" title="获取所有的常量池信息"></a>获取所有的常量池信息</h3><p>根据上面的实现，可以通过一个计数循环（通过 <code>ConstPool.getSize()</code> 获取所有常量池信息的个数）来获取所有的常量池信息，如下 <sup>[7]</sup>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> List&lt;Object&gt; <span class="title function_">getConstPoolItems</span><span class="params">(ConstPool cp)</span> &#123;</span><br><span class="line">    List&lt;Object&gt; objects = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(cp.getSize());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计数循环，获取所有的常量池信息。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cp.getSize(); i++) &#123;</span><br><span class="line">        objects.add(getConstPoolItem(cp, i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objects;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反射调用 ConstPool.getItem()。</span></span><br><span class="line"><span class="comment"> * Calls ConstPool.getItem() method reflectively.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cp The ConstPool object.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index The index of items.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The XXXInfo Object. Since it&#x27;s invisible, return Object instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> Object <span class="title function_">getConstPoolItem</span><span class="params">(ConstPool cp, <span class="type">int</span> index)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 考虑到反射的性能损耗，这里用了个 Method 的缓存。</span></span><br><span class="line">    <span class="keyword">if</span> (getItemMethodCache == <span class="literal">null</span>) &#123;</span><br><span class="line">        Class&lt;ConstPool&gt; cpc = ConstPool.class;</span><br><span class="line">        Method getItemMethod;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            getItemMethod = cpc.getDeclaredMethod(<span class="string">&quot;getItem&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line">            getItemMethod.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            getItemMethodCache = getItemMethod;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Javassist internal method changed.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getItemMethodCache.invoke(cp, index);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Javassist internal method changed.&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="获取常量池中的错误码-1"><a href="#获取常量池中的错误码-1" class="headerlink" title="获取常量池中的错误码"></a>获取常量池中的错误码</h3><p>只有 Utf8Info 才是实际承载字符串信息的常量池项目，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Utf8Info</span> <span class="keyword">extends</span> <span class="title class_">ConstInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">tag</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    String string;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>考虑到上述情况，我们只用在常量池中找出所有的 Utf8Info 对象，并获取它对应的字符串就行。具体的代码如下 <sup>[7]</sup>：</p>
<blockquote>
<p><strong>备注：</strong></p>
<p>这里换了一种查找方式，并不是直接筛选出 Utf8Info，而是筛选出所有带 <code>String string;</code>  声明的 ConstInfo 子类的实例，之后获取 <code>string</code> 变量的内容。</p>
<p><small>(R5.10.30 补 - 其实当时是认为 StringInfo 类也存放了实际的字符串内容而这么做的…… 但实际上它只存放了个对应字符串的常量池索引……)</small></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getConstPoolStringItems</span><span class="params">(ConstPool cp)</span> &#123;</span><br><span class="line">    List&lt;Object&gt; objects = getConstPoolItems(cp);</span><br><span class="line">    List&lt;String&gt; stringItems = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(cp.getSize());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Object item : objects) &#123;</span><br><span class="line"></span><br><span class="line">        Field stringField;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (item != <span class="literal">null</span>) &#123;</span><br><span class="line">            stringField = getStringFieldInConstPoolItems(item);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (stringField == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Object fieldData;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fieldData = stringField.get(item);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Javassist internal field changed.&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fieldData.getClass() == String.class) &#123;</span><br><span class="line">                stringItems.add((String) fieldData);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> stringItems;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此之后，根据错误码格式（见最上述引用）使用正则表达式筛选出来便可，代码如下 <sup>[9]</sup>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In ErrorCodeExtractor.java: </span></span><br><span class="line"><span class="comment">// Pattern ERROR_CODE_PATTERN = Pattern.compile(&quot;\\d+-\\d+&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getErrorCodes</span><span class="params">(String classFilePath)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">ClassFile</span> <span class="variable">clsF</span> <span class="operator">=</span> JavassistUtils.openClassFile(classFilePath);</span><br><span class="line">    <span class="type">ConstPool</span> <span class="variable">cp</span> <span class="operator">=</span> clsF.getConstPool();</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; cpItems = JavassistUtils.getConstPoolStringItems(cp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cpItems.stream()</span><br><span class="line">    		.filter(x -&gt; ERROR_CODE_PATTERN.matcher(x).matches())</span><br><span class="line">    		.collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其返回值便是所有的错误码。</p>
<p>当然，这只解决了获取全部错误码的问题。至于之后该怎么获得所有的 Logger 调用等等，还请看下回分解。</p>
<hr>
<p>备注：</p>
<ol>
<li><p>有关环境：</p>
<p>イ、命令行 Maven 运行于 OpenJDK 19 环境下。</p>
<p>ロ、对于 Dubbo 项目 IDEA JDK 配置为基于 OpenJDK 8 的 GraalVM 21.3.1 的 JDK。</p>
<p>ハ、在编写错误码 Logger 调用自动检测程序时，使用的是 OpenJDK 19 版本，但调节了兼容性设置到 JDK 8。</p>
<p>ニ、在 Dubbo CI 运行时使用 Azul OpenJDK 17。</p>
</li>
</ol>
<hr>
<p>引用和参考：</p>
<style>
    small p {
        color : grey;
        line-height : 1em !important;
    }
</style>
<small>

<p>[1] Apache Dubbo - 错误码机制介绍</p>
<p><a target="_blank" rel="noopener" href="https://dubbo.apache.org/faq/intro">https://dubbo.apache.org/faq/intro</a></p>
<p>[2] Apache Dubbo Source Code - org.apache.dubbo.common.DeprecatedMethodInvocationCounter</p>
<p><a target="_blank" rel="noopener" href="https://github.com/apache/dubbo/blob/5ae875d951d354a2f2d3316fc08cab406a3e947e/dubbo-common/src/main/java/org/apache/dubbo/common/DeprecatedMethodInvocationCounter.java">https://github.com/apache/dubbo/blob/5ae875d951d354a2f2d3316fc08cab406a3e947e/dubbo-common/src/main/java/org/apache/dubbo/common/DeprecatedMethodInvocationCounter.java</a></p>
<p>[3] Apache Dubbo Source Code - org.apache.dubbo.common.constants.DeprecatedMethodInvocationCounterConstants</p>
<p><a target="_blank" rel="noopener" href="https://github.com/apache/dubbo/blob/5ae875d951d354a2f2d3316fc08cab406a3e947e/dubbo-common/src/main/java/org/apache/dubbo/common/constants/DeprecatedMethodInvocationCounterConstants.java">https://github.com/apache/dubbo/blob/5ae875d951d354a2f2d3316fc08cab406a3e947e/dubbo-common/src/main/java/org/apache/dubbo/common/constants/DeprecatedMethodInvocationCounterConstants.java</a></p>
<p>[4] Apache Dubbo Source Code - org.apache.dubbo.registry.support.CacheableFailbackRegistry</p>
<p><a target="_blank" rel="noopener" href="https://github.com/apache/dubbo/blob/3.3/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/CacheableFailbackRegistry.java">https://github.com/apache/dubbo/blob/3.3/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/CacheableFailbackRegistry.java</a></p>
<p>[5] Apache Dubbo Source Code - org.apache.dubbo.registry.support.CacheableFailbackRegistry (error code was not managed in this version)</p>
<p><a target="_blank" rel="noopener" href="https://github.com/apache/dubbo/blob/7359a98fdd0ff274f50b0f6561d249d133d0f2fb/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/CacheableFailbackRegistry.java">https://github.com/apache/dubbo/blob/7359a98fdd0ff274f50b0f6561d249d133d0f2fb/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/CacheableFailbackRegistry.java</a></p>
<p>[6] Javassist Tutorial</p>
<p><a target="_blank" rel="noopener" href="http://www.javassist.org/tutorial/tutorial3.html#intro">http://www.javassist.org/tutorial/tutorial3.html#intro</a></p>
<p>[7] Apache Dubbo Error Code Inspector Source Code (in dubbo-test-tools) - org.apache.dubbo.errorcode.extractor.JavassistUtils</p>
<p><a target="_blank" rel="noopener" href="https://github.com/apache/dubbo-test-tools/blob/main/dubbo-error-code-inspector/src/main/java/org/apache/dubbo/errorcode/extractor/JavassistUtils.java">https://github.com/apache/dubbo-test-tools/blob/main/dubbo-error-code-inspector/src/main/java/org/apache/dubbo/errorcode/extractor/JavassistUtils.java</a></p>
<p>[8] Javassist API Docs - javassist.bytecode.ClassFile#getConstPool()</p>
<p><a target="_blank" rel="noopener" href="https://www.javassist.org/html/javassist/bytecode/ClassFile.html#getConstPool()">https://www.javassist.org/html/javassist/bytecode/ClassFile.html#getConstPool()</a></p>
<p>[9]  Apache Dubbo Error Code Inspector Source Code (in dubbo-test-tools) - org.apache.dubbo.errorcode.extractor.JavassistConstantPoolErrorCodeExtractor</p>
<p><a target="_blank" rel="noopener" href="https://github.com/apache/dubbo-test-tools/blob/main/dubbo-error-code-inspector/src/main/java/org/apache/dubbo/errorcode/extractor/JavassistConstantPoolErrorCodeExtractor.java">https://github.com/apache/dubbo-test-tools/blob/main/dubbo-error-code-inspector/src/main/java/org/apache/dubbo/errorcode/extractor/JavassistConstantPoolErrorCodeExtractor.java</a></p>
</small>

<hr />

<p>[ TART - Dubbo (ECI) - T3 - R5 ] @HQ</p>
<p>(SNa - ECI, SNu - 1)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://win120a.github.io/2023/05/19/dubbo-eci-1/" data-id="cly2lczyx0001e7pygexkdcsn" data-title="Dubbo 在 CI 中自动检查错误码 Logger 调用的实现（一） - 背景和错误码的获取" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Apache-Dubbo/" rel="tag">Apache Dubbo</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Dubbo-ECI/" rel="tag">Dubbo ECI</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Javassist/" rel="tag">Javassist</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-what-happened-on-annotations" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/27/what-happened-on-annotations/" class="article-date">
  <time class="dt-published" datetime="2021-01-27T14:48:31.000Z" itemprop="datePublished">2021-01-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/27/what-happened-on-annotations/">源码探索 | 从 Java 层面分析注解 (Annotation) 从编译到运行时发生了什么</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="写作动机"><a href="#写作动机" class="headerlink" title="写作动机"></a>写作动机</h1><p>近期编写了一个基于注解的自动注入功能，于是就对 Java 的注解的工作原理产生了兴趣。下面是我对 Java 注解从编译时的行为到运行时提取注解的行为进行一定的（Java 层面上的）分析，愿能解释 Java 注解的工作原理。</p>
<h1 id="全文约定"><a href="#全文约定" class="headerlink" title="全文约定"></a>全文约定</h1><p>定义注解如下：</p>
<p>（运行时可见）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestRuntimeVisibleAnnotation &#123;</span><br><span class="line">    String <span class="title function_">pathInResources</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br />
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.FIELD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RuntimeVisibleAnnotation2 &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">data</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; theClass() <span class="keyword">default</span> Object.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>（出现于 class 文件）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.CLASS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestClassFileAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br />

<p>（只能被编译器的 APT 处理）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestSourceFileAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们可以知道 @TestRuntimeVisibleAnnotation 和 @RuntimeVisibleAnnotation2 是用来修饰 Field 且在运行时可见的注解，@TestClassFileAnnotation 是用来修饰类型且只能在 Class 文件中可见的注解（不能被运行时查到），@TestSourceFileAnnotation 是一个修饰类型并且只能被编译时的注解处理器 (APT) 处理，class 文件并不可见。</p>
<h1 id="编译时发生的事情"><a href="#编译时发生的事情" class="headerlink" title="编译时发生的事情"></a>编译时发生的事情</h1><h2 id="注解一方"><a href="#注解一方" class="headerlink" title="注解一方"></a>注解一方</h2><h3 id="编译后的-class-文件成了啥样"><a href="#编译后的-class-文件成了啥样" class="headerlink" title="编译后的 class 文件成了啥样"></a>编译后的 class 文件成了啥样</h3><p>我们使用 javap 工具来分析测试 TestRuntimeVisibleAnnotation 的 class 文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -v TestRuntimeVisibleAnnotation.class</span><br></pre></td></tr></table></figure>



<p>发现输出如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Compiled from <span class="string">&quot;TestRuntimeVisibleAnnotation.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TestRuntimeVisibleAnnotation</span> <span class="keyword">extends</span> <span class="title class_">java</span>.lang.annotation.Annotation</span><br><span class="line">  minor version: <span class="number">65535</span></span><br><span class="line">  major version: <span class="number">59</span></span><br><span class="line">  flags: (<span class="number">0x2601</span>) ACC_PUBLIC, ACC_INTERFACE, ACC_ABSTRACT, ACC_ANNOTATION</span><br><span class="line">  this_class: #<span class="number">1</span>                          <span class="comment">// TestRuntimeVisibleAnnotation</span></span><br><span class="line">  super_class: #<span class="number">3</span>                         <span class="comment">// java/lang/Object</span></span><br><span class="line">  interfaces: <span class="number">1</span>, fields: <span class="number">0</span>, methods: <span class="number">1</span>, attributes: <span class="number">2</span></span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Class              #<span class="number">2</span>             <span class="comment">// TestRuntimeVisibleAnnotation</span></span><br><span class="line">   #<span class="number">2</span> = Utf8               TestRuntimeVisibleAnnotation</span><br><span class="line">   #<span class="number">3</span> = Class              #<span class="number">4</span>             <span class="comment">// java/lang/Object</span></span><br><span class="line">   #<span class="number">4</span> = Utf8               java/lang/Object</span><br><span class="line">   #<span class="number">5</span> = Class              #<span class="number">6</span>             <span class="comment">// java/lang/annotation/Annotation</span></span><br><span class="line">   #<span class="number">6</span> = Utf8               java/lang/annotation/Annotation</span><br><span class="line">   #<span class="number">7</span> = Utf8               pathInResources</span><br><span class="line">   #<span class="number">8</span> = Utf8               ()Ljava/lang/String;</span><br><span class="line">   #<span class="number">9</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">10</span> = Utf8               TestRuntimeVisibleAnnotation.java</span><br><span class="line">  #<span class="number">11</span> = Utf8               RuntimeVisibleAnnotations</span><br><span class="line">  #<span class="number">12</span> = Utf8               Ljava/lang/annotation/Target;</span><br><span class="line">  #<span class="number">13</span> = Utf8               value</span><br><span class="line">  #<span class="number">14</span> = Utf8               Ljava/lang/annotation/ElementType;</span><br><span class="line">  #<span class="number">15</span> = Utf8               FIELD</span><br><span class="line">  #<span class="number">16</span> = Utf8               TYPE</span><br><span class="line">  #<span class="number">17</span> = Utf8               Ljava/lang/annotation/Retention;</span><br><span class="line">  #<span class="number">18</span> = Utf8               Ljava/lang/annotation/RetentionPolicy;</span><br><span class="line">  #<span class="number">19</span> = Utf8               RUNTIME</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> java.lang.String <span class="title function_">pathInResources</span><span class="params">()</span>;</span><br><span class="line">    descriptor: ()Ljava/lang/String;</span><br><span class="line">    flags: (<span class="number">0x0401</span>) ACC_PUBLIC, ACC_ABSTRACT</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;TestRuntimeVisibleAnnotation.java&quot;</span></span><br><span class="line">RuntimeVisibleAnnotations:</span><br><span class="line">  <span class="number">0</span>: #<span class="number">12</span>(#<span class="number">13</span>=[e#<span class="number">14.</span>#<span class="number">15</span>,e#<span class="number">14.</span>#<span class="number">16</span>])</span><br><span class="line">    java.lang.annotation.Target(</span><br><span class="line">      value=[Ljava/lang/annotation/ElementType;.FIELD,Ljava/lang/annotation/ElementType;.TYPE]</span><br><span class="line">    )</span><br><span class="line">  <span class="number">1</span>: #<span class="number">17</span>(#<span class="number">13</span>=e#<span class="number">18.</span>#<span class="number">19</span>)</span><br><span class="line">    java.lang.annotation.Retention(</span><br><span class="line">      value=Ljava/lang/annotation/RetentionPolicy;.RUNTIME</span><br><span class="line">    )</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>根据 Java 虚拟机规范 [1]，class 文件的 access_flags 决定了这个类（或变量等）的性质以及访问的权限。</p>
<p><img src="/2021/01/27/what-happened-on-annotations/jvms_af_1.png"></p>
<p><img src="/2021/01/27/what-happened-on-annotations/jvms_af_2.png" alt="The &quot;access_flags&quot; part of Class File structure&quot; section of The Java Virtual Machine Specification"></p>
<p>根据 javap 的输出 中的 flags： </p>
<p><code>(0x2601) ACC_PUBLIC, ACC_INTERFACE, ACC_ABSTRACT, ACC_ANNOTATION</code></p>
<p>并查表可知：</p>
<p>ACC_PUBLIC:  表示 public 访问权限。</p>
<p>ACC_INTERFACE:  表示这是一个接口。</p>
<p>ACC_ABSTRACT:  这是一个特殊的标识，表示这是抽象的（根据规范，ACC_INTERFACE 存在时，这个也要存在）。</p>
<p>ACC_ANNOTAION:  表示这是一个注解对象。</p>
<p>可知注解的真实身份是一种特殊的接口。它是 <code>java.lang.annotation.Annotation</code> 的子接口。而 <code>String pathInResources();</code>  最终也变成了这个 “接口” 的方法声明。</p>
<h2 id="使用注解的一方"><a href="#使用注解的一方" class="headerlink" title="使用注解的一方"></a>使用注解的一方</h2><h3 id="编译时发生的事情-1"><a href="#编译时发生的事情-1" class="headerlink" title="编译时发生的事情"></a>编译时发生的事情</h3><p>下面是一个测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestClassFileAnnotation</span></span><br><span class="line"><span class="meta">@TestSourceFileAnnotation</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Class2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TestRuntimeVisibleAnnotation(pathInResources = &quot;1&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">test</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>对这个类进行编译，反编译的结果如下：</p>
<p><img src="/2021/01/27/what-happened-on-annotations/decompilingResult.jpg" alt="Decompiling Result"></p>
<p>我们可以看到，@TestSourceFileAnnotation 消失了，这与这个注解的 @Retention 的值是相匹配的。</p>
<p>由这一过程可以看到，javac 并没有把这个注解写入 class 文件里头。打开 javac 写入 class 文件的代码 [2]，并定位到 473 行的 writeJavaAnnotations() 的部分代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment"> * Writing Java-language annotations (aka metadata, attributes)</span></span><br><span class="line"><span class="comment"> **********************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Write Java-language annotations; return number of JVM</span></span><br><span class="line"><span class="comment"> *  attributes written (zero or one).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">writeJavaAnnotations</span><span class="params">(List&lt;Attribute.Compound&gt; attrs)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (attrs.isEmpty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ListBuffer&lt;Attribute.Compound&gt; visibles = <span class="keyword">new</span> <span class="title class_">ListBuffer</span>&lt;&gt;();</span><br><span class="line">    ListBuffer&lt;Attribute.Compound&gt; invisibles = <span class="keyword">new</span> <span class="title class_">ListBuffer</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Attribute.Compound a : attrs) &#123;</span><br><span class="line">        <span class="comment">// 根据 Retention 的属性决定写入到哪个属性表。</span></span><br><span class="line">        <span class="keyword">switch</span> (types.getRetention(a)) &#123;</span><br><span class="line">            <span class="keyword">case</span> SOURCE: <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CLASS: invisibles.append(a); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RUNTIME: visibles.append(a); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="comment">// /* fail soft */ throw new AssertionError(vis);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据刚刚判定的结果写入到 class 文件的属性表</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">attrCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (visibles.length() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">attrIndex</span> <span class="operator">=</span> writeAttr(names.RuntimeVisibleAnnotations);</span><br><span class="line">        databuf.appendChar(visibles.length());</span><br><span class="line">        <span class="keyword">for</span> (Attribute.Compound a : visibles)</span><br><span class="line">            writeCompoundAttribute(a);</span><br><span class="line">        endAttr(attrIndex);</span><br><span class="line">        attrCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (invisibles.length() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> attrCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="编译之后的-class-文件变成了啥样（javap-分析）"><a href="#编译之后的-class-文件变成了啥样（javap-分析）" class="headerlink" title="编译之后的 class 文件变成了啥样（javap 分析）"></a>编译之后的 class 文件变成了啥样（javap 分析）</h3><p>我们使用 javap 工具来分析测试类 Class2 的 class 文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -p -v Class2.class</span><br></pre></td></tr></table></figure>



<p>发现输出如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">Compiled from <span class="string">&quot;Class2.java&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Class2</span></span><br><span class="line">  minor version: <span class="number">65535</span></span><br><span class="line">  major version: <span class="number">59</span></span><br><span class="line">  flags: (<span class="number">0x0021</span>) ACC_PUBLIC, ACC_SUPER</span><br><span class="line">  this_class: #<span class="number">7</span>                          <span class="comment">// Class2</span></span><br><span class="line">  super_class: #<span class="number">2</span>                         <span class="comment">// java/lang/Object</span></span><br><span class="line">  interfaces: <span class="number">0</span>, fields: <span class="number">1</span>, methods: <span class="number">1</span>, attributes: <span class="number">2</span></span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">2.</span>#<span class="number">3</span>          <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Class              #<span class="number">4</span>             <span class="comment">// java/lang/Object</span></span><br><span class="line">   #<span class="number">3</span> = NameAndType        #<span class="number">5</span>:#<span class="number">6</span>          <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">4</span> = Utf8               java/lang/Object</span><br><span class="line">   #<span class="number">5</span> = Utf8               &lt;init&gt;</span><br><span class="line">   #<span class="number">6</span> = Utf8               ()V</span><br><span class="line">   #<span class="number">7</span> = Class              #<span class="number">8</span>             <span class="comment">// Class2</span></span><br><span class="line">   #<span class="number">8</span> = Utf8               Class2</span><br><span class="line">   #<span class="number">9</span> = Utf8               test</span><br><span class="line">  #<span class="number">10</span> = Utf8               Ljava/lang/String;</span><br><span class="line">  #<span class="number">11</span> = Utf8               ConstantValue</span><br><span class="line">  #<span class="number">12</span> = String             #<span class="number">13</span>            <span class="comment">// 1</span></span><br><span class="line">  #<span class="number">13</span> = Utf8               <span class="number">1</span></span><br><span class="line">  #<span class="number">14</span> = Utf8               RuntimeVisibleAnnotations</span><br><span class="line">  #<span class="number">15</span> = Utf8               LTestRuntimeVisibleAnnotation;</span><br><span class="line">  #<span class="number">16</span> = Utf8               pathInResources</span><br><span class="line">  #<span class="number">17</span> = Utf8               Code</span><br><span class="line">  #<span class="number">18</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">19</span> = Utf8               LocalVariableTable</span><br><span class="line">  #<span class="number">20</span> = Utf8               <span class="built_in">this</span></span><br><span class="line">  #<span class="number">21</span> = Utf8               LClass2;</span><br><span class="line">  #<span class="number">22</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">23</span> = Utf8               Class2.java</span><br><span class="line">  #<span class="number">24</span> = Utf8               RuntimeInvisibleAnnotations</span><br><span class="line">  #<span class="number">25</span> = Utf8               LTestClassFileAnnotation;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String test;</span><br><span class="line">    descriptor: Ljava/lang/String;</span><br><span class="line">    flags: (<span class="number">0x001a</span>) ACC_PRIVATE, ACC_STATIC, ACC_FINAL</span><br><span class="line">    ConstantValue: String <span class="number">1</span></span><br><span class="line">    RuntimeVisibleAnnotations:</span><br><span class="line">      <span class="number">0</span>: #<span class="number">15</span>(#<span class="number">16</span>=s#<span class="number">13</span>)</span><br><span class="line">        TestRuntimeVisibleAnnotation(</span><br><span class="line">          pathInResources=<span class="string">&quot;1&quot;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Class2</span><span class="params">()</span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (<span class="number">0x0001</span>) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">4</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="built_in">this</span>   LClass2;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;Class2.java&quot;</span></span><br><span class="line">RuntimeInvisibleAnnotations:</span><br><span class="line">  <span class="number">0</span>: #<span class="number">25</span>()</span><br><span class="line">    TestClassFileAnnotation</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>根据输出，我们可以看到 Retention 指定成 RetentionPolicy.CLASS 的注解是写到了被修饰对象属性表的 RuntimeInvisibleAnnotations 项目中。而指定成 RetentionPolicy.RUNTIME 的注解写到了被修饰对象属性表的 RuntimeVisibleAnnotation 项目中。</p>
<h3 id="在-class-文件中表示对注解的引用（字节码的分析）"><a href="#在-class-文件中表示对注解的引用（字节码的分析）" class="headerlink" title="在 class 文件中表示对注解的引用（字节码的分析）"></a>在 class 文件中表示对注解的引用（字节码的分析）</h3><p>根据 Class 文件格式规范 [1]</p>
<p><img src="/2021/01/27/what-happened-on-annotations/jvms_classfile.png" alt="&quot;The ClassFile Structure&quot; section of The Java Virtual Machine Specification"></p>
<p>我们发现常量池之后出现的元素的声明的顺序分别是：类本身的有关信息、Field 的信息、方法的信息和修饰在这个类的属性。</p>
<p>我们用十六进制编辑器打开 class 文件，按这个顺序进行人工解析：</p>
<p><img src="/2021/01/27/what-happened-on-annotations/manualInterpreting1.png" alt="Manual Interpreting of Class file"></p>
<p>发现到 RuntimeVisibleAnnotations 属性的时候，它的属性值和 annotations 的值相同。</p>
<p>根据 Java 虚拟机规范 [1]：</p>
<p><img src="/2021/01/27/what-happened-on-annotations/jvms_rtva.png" alt="The format of RuntimeVisibleAnnotations attribute of The Java Virtual Machine Specification"></p>
<p>我们对这个属性进行进一步的拆分：</p>
<p><img src="/2021/01/27/what-happened-on-annotations/manualInterpreting2.png" alt="Manual Splitting of byte code"></p>
<p>这决定了注解的属性的一部分。但是这需要常量池的配合才能获取完整的属性。</p>
<h1 id="运行时"><a href="#运行时" class="headerlink" title="运行时"></a>运行时</h1><h2 id="运行时类型探秘"><a href="#运行时类型探秘" class="headerlink" title="运行时类型探秘"></a>运行时类型探秘</h2><p>我们修改一下测试类，探究一下获取到的注解对象的运行时类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="meta">@TestRuntimeVisibleAnnotation</span> (pathInResources = <span class="string">&quot;class2&quot;</span>)</span><br><span class="line"><span class="meta">@TestClassFileAnnotation</span></span><br><span class="line"><span class="meta">@TestSourceFileAnnotation</span></span><br><span class="line"><span class="meta">@RuntimeVisibleAnnotation2</span> (data = <span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Class2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TestRuntimeVisibleAnnotation(pathInResources = &quot;123&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">test</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Class&lt;Class2&gt; klass = Class2.class;</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(klass.getDeclaredAnnotations()));</span><br><span class="line"></span><br><span class="line">        <span class="type">var</span> <span class="variable">annotationObjectOfField</span> <span class="operator">=</span> klass.getDeclaredFields()[<span class="number">0</span>].</span><br><span class="line">                getAnnotation(TestRuntimeVisibleAnnotation.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">var</span> <span class="variable">annotationObjectOfClass</span> <span class="operator">=</span> klass.getAnnotation(TestRuntimeVisibleAnnotation.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">var</span> <span class="variable">anotherAnnotationObjectOfClass</span> <span class="operator">=</span> klass.getAnnotation(RuntimeVisibleAnnotation2.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Hash Code of annotationObjectOfField: &quot;</span> </span><br><span class="line">                           + annotationObjectOfField.hashCode());</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;Identity Hash Code of annotationObjectOfField: &quot;</span> </span><br><span class="line">                           + System.identityHashCode(annotationObjectOfField));</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;Class name of annotationObjectOfField: &quot;</span> </span><br><span class="line">                           + annotationObjectOfField.getClass().getName());</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Hash Code of annotationObjectOfClass: &quot;</span> </span><br><span class="line">                           + annotationObjectOfClass.hashCode());</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;Identity Hash Code of annotationObjectOfClass: &quot;</span></span><br><span class="line">                           + System.identityHashCode(annotationObjectOfClass));</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;Class name of annotationObjectOfClass: &quot;</span></span><br><span class="line">                           + annotationObjectOfClass.getClass().getName());</span><br><span class="line">        </span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Hash Code of anotherAnnotationObjectOfClass: &quot;</span></span><br><span class="line">                           + anotherAnnotationObjectOfClass.hashCode());</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;Identity Hash Code of anotherAnnotationObjectOfClass: &quot;</span></span><br><span class="line">                           + System.identityHashCode(anotherAnnotationObjectOfClass));</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;Class name of anotherAnnotationObjectOfClass: &quot;</span></span><br><span class="line">                           + anotherAnnotationObjectOfClass.getClass().getName());</span><br><span class="line"></span><br><span class="line">        System.out.println(annotationObjectOfField.pathInResources());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br />

<p>运行输出如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">@TestRuntimeVisibleAnnotation(pathInResources=&quot;class2&quot;)</span>, <span class="meta">@RuntimeVisibleAnnotation2(theClass=java.lang.Object.class, data=1)</span>]</span><br><span class="line">Hash Code of annotationObjectOfField: -<span class="number">995842473</span></span><br><span class="line">Identity Hash Code of annotationObjectOfField: <span class="number">1368884364</span></span><br><span class="line">Class name of annotationObjectOfField: com.sun.proxy.$Proxy1</span><br><span class="line"></span><br><span class="line">Hash Code of annotationObjectOfClass: <span class="number">1806409183</span></span><br><span class="line">Identity Hash Code of annotationObjectOfClass: <span class="number">772777427</span></span><br><span class="line">Class name of annotationObjectOfClass: com.sun.proxy.$Proxy1</span><br><span class="line">    </span><br><span class="line">Hash Code of anotherAnnotationObjectOfClass: <span class="number">291781459</span></span><br><span class="line">Identity Hash Code of anotherAnnotationObjectOfClass: <span class="number">83954662</span></span><br><span class="line">Class name of anotherAnnotationObjectOfClass: com.sun.proxy.$Proxy2</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>



<p>根据输出中的 <code>Class name of XXX</code> 的结果的 <code>com.sun.proxy.$ProxyX</code> 可以知道，在运行时当中获取的注解的实例，是由动态代理产生的。并且是一个注解一个对应一个类。</p>
<h2 id="Java-标准库对注解的解析"><a href="#Java-标准库对注解的解析" class="headerlink" title="Java 标准库对注解的解析"></a>Java 标准库对注解的解析</h2><h3 id="Field-的-getAnnotation-方法"><a href="#Field-的-getAnnotation-方法" class="headerlink" title="Field 的 getAnnotation 方法"></a>Field 的 getAnnotation 方法</h3><p>回到 “运行时类型探秘” 的测试类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">annotationObjectOfField</span> <span class="operator">=</span> klass.getDeclaredFields()[<span class="number">0</span>].</span><br><span class="line">                getAnnotation(TestRuntimeVisibleAnnotation.class);</span><br><span class="line"></span><br><span class="line"><span class="type">var</span> <span class="variable">annotationObjectOfClass</span> <span class="operator">=</span> klass.getAnnotation(TestRuntimeVisibleAnnotation.class);</span><br><span class="line"></span><br><span class="line"><span class="type">var</span> <span class="variable">anotherAnnotationObjectOfClass</span> <span class="operator">=</span> klass.getAnnotation(RuntimeVisibleAnnotation2.class);</span><br></pre></td></tr></table></figure>



<p>我们从 Field 类的 getAnnotation 方法 [3] 入手。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; T <span class="title function_">getAnnotation</span><span class="params">(Class&lt;T&gt; annotationClass)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(annotationClass);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从 declaredAnnotations 获取对应类的 Annotation 对象。</span></span><br><span class="line">    <span class="comment">// 因为 get 方法返回的是 Annotation 即父接口对象。</span></span><br><span class="line">    <span class="comment">// 所以将返回的 Annotation 对象转换成指定的注解类对象（相当于强转）。</span></span><br><span class="line">    <span class="keyword">return</span> annotationClass.cast(declaredAnnotations().get(annotationClass));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="查找修饰-Field-的注解-declaredAnnotations-方法"><a href="#查找修饰-Field-的注解-declaredAnnotations-方法" class="headerlink" title="查找修饰 Field 的注解 - declaredAnnotations() 方法"></a>查找修饰 Field 的注解 - declaredAnnotations() 方法</h3><p>对这个方法的分析如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;, Annotation&gt; declaredAnnotations() &#123;</span><br><span class="line">    Map&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;, Annotation&gt; declAnnos;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这用了 Double Checked Locking 的机制，用来检查是否有了缓存。</span></span><br><span class="line">    <span class="comment">// 如果有了缓存，就不需要加锁创建缓存了。</span></span><br><span class="line">    <span class="comment">// 这主要是为了防止多线程同时调用这一方法产生的混乱。</span></span><br><span class="line">    <span class="keyword">if</span> ((declAnnos = declaredAnnotations) == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((declAnnos = declaredAnnotations) == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Class 的 getField 等方法返回的是经过复制的 Field 对象，</span></span><br><span class="line">                <span class="comment">// 这是为了找到最初由运行时生成的 Field 对象</span></span><br><span class="line">                <span class="type">Field</span> <span class="variable">root</span> <span class="operator">=</span> <span class="built_in">this</span>.root;</span><br><span class="line">                <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">                    declAnnos = root.declaredAnnotations();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 但是，无论是什么情况，最终都要调用到这里。</span></span><br><span class="line">                    <span class="comment">// 这将注解的解析交给了 AnnotationParser 处理。</span></span><br><span class="line">                    declAnnos = AnnotationParser.parseAnnotations(</span><br><span class="line">                        annotations,</span><br><span class="line">                        SharedSecrets.getJavaLangAccess()</span><br><span class="line">                            .getConstantPool(getDeclaringClass()),</span><br><span class="line">                        getDeclaringClass());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将获取到的注解缓存起来。</span></span><br><span class="line">                declaredAnnotations = declAnnos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> declAnnos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>对 Field 中的 declaredAnnotation() 方法中的的语句打断点，进行 Debug。根据 Variables，我们获取到这个 Field 的 annotations 的值：</p>
<p><img src="/2021/01/27/what-happened-on-annotations/annotationsValue.png" alt="Value of &quot;annotations&quot;"></p>
<p>将这个值抄写下来 （十六进制）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00 01 00 67 00 01 00 60 73 00 68</span><br></pre></td></tr></table></figure>



<p>根据上文，这是 RuntimeVisibleAnnotations 的属性值。</p>
<p><img src="/2021/01/27/what-happened-on-annotations/lookup.png" alt="Looking up the value"></p>
<p>这表示了注解的数据。</p>
<h3 id="分析注解数据的方法-parseAnnotation-系列方法"><a href="#分析注解数据的方法-parseAnnotation-系列方法" class="headerlink" title="分析注解数据的方法 - parseAnnotation 系列方法"></a>分析注解数据的方法 - parseAnnotation 系列方法</h3><h4 id="parseAnnotations-解析多个注解的入口方法"><a href="#parseAnnotations-解析多个注解的入口方法" class="headerlink" title="parseAnnotations - 解析多个注解的入口方法"></a>parseAnnotations - 解析多个注解的入口方法</h4><p>接下来分析 parseAnnotations 方法 [4]。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;, Annotation&gt; parseAnnotations(</span><br><span class="line">    <span class="type">byte</span>[] rawAnnotations,</span><br><span class="line">    ConstantPool constPool,</span><br><span class="line">    Class&lt;?&gt; container) &#123;</span><br><span class="line">    <span class="keyword">if</span> (rawAnnotations == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyMap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 委派给 2 号方法。</span></span><br><span class="line">        <span class="keyword">return</span> parseAnnotations2(rawAnnotations, constPool, container, <span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(BufferUnderflowException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AnnotationFormatError</span>(<span class="string">&quot;Unexpected end of annotations.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IllegalArgumentException e) &#123;</span><br><span class="line">        <span class="comment">// Type mismatch in constant pool</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AnnotationFormatError</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="解析多个注解的-2-号方法-parseAnnotations2"><a href="#解析多个注解的-2-号方法-parseAnnotations2" class="headerlink" title="解析多个注解的 2 号方法 - parseAnnotations2"></a>解析多个注解的 2 号方法 - parseAnnotations2</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2 号方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;, Annotation&gt; parseAnnotations2(</span><br><span class="line">    <span class="type">byte</span>[] rawAnnotations,</span><br><span class="line">    ConstantPool constPool,</span><br><span class="line">    Class&lt;?&gt; container,</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;[] selectAnnotationClasses) &#123;</span><br><span class="line">    Map&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;, Annotation&gt; result =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;, Annotation&gt;();</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.wrap(rawAnnotations);</span><br><span class="line">    <span class="comment">// 获取前两个字节 （确定多少个注解）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numAnnotations</span> <span class="operator">=</span> buf.getShort() &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numAnnotations; i++) &#123;</span><br><span class="line">        <span class="comment">// 委派给识别单个注解的 3 号方法。</span></span><br><span class="line">        <span class="type">Annotation</span> <span class="variable">a</span> <span class="operator">=</span> parseAnnotation2(buf, </span><br><span class="line">                                        constPool, </span><br><span class="line">                                        container, </span><br><span class="line">                                        <span class="literal">false</span>, selectAnnotationClasses);</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="literal">null</span>) &#123;</span><br><span class="line">            Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; klass = a.annotationType();</span><br><span class="line">            <span class="keyword">if</span> (AnnotationType.getInstance(klass).retention() == </span><br><span class="line">                RetentionPolicy.RUNTIME &amp;&amp; result.put(klass, a) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AnnotationFormatError</span>(</span><br><span class="line">                    <span class="string">&quot;Duplicate annotation for class: &quot;</span>+klass+<span class="string">&quot;: &quot;</span> + a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="解析单个注解的-3-号方法-parseAnnotation2"><a href="#解析单个注解的-3-号方法-parseAnnotation2" class="headerlink" title="解析单个注解的 3 号方法 - parseAnnotation2"></a>解析单个注解的 3 号方法 - parseAnnotation2</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Annotation <span class="title function_">parseAnnotation2</span><span class="params">(ByteBuffer buf,</span></span><br><span class="line"><span class="params">                                           ConstantPool constPool,</span></span><br><span class="line"><span class="params">                                           Class&lt;?&gt; container,</span></span><br><span class="line"><span class="params">                                           <span class="type">boolean</span> exceptionOnMissingAnnotationClass,</span></span><br><span class="line"><span class="params">                                           Class&lt;? extends Annotation&gt;[] selectAnnotationClasses)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取注解的类型引用（常量池中注解类条目的序号）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">typeIndex</span> <span class="operator">=</span> buf.getShort() &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; annotationClass = <span class="literal">null</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sig</span> <span class="operator">=</span> <span class="string">&quot;[unknown]&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取常量池中注解类的对应类名</span></span><br><span class="line">            sig = constPool.getUTF8At(typeIndex);</span><br><span class="line">            <span class="comment">// 将常量池表示转化为 Class 对象表示（并转化为 Annotation 的泛型）</span></span><br><span class="line">            annotationClass = (Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;)parseSig(sig, container);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">            <span class="comment">// support obsolete early jsr175 format class files - 向后兼容</span></span><br><span class="line">            annotationClass = (Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;)constPool.getClassAt(typeIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoClassDefFoundError | TypeNotPresentException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 异常处理略</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// selectAnnotationClasses 根据上面的调用是 null，故不执行。</span></span><br><span class="line">    <span class="keyword">if</span> (selectAnnotationClasses != <span class="literal">null</span> &amp;&amp; </span><br><span class="line">        !contains(selectAnnotationClasses, annotationClass)) &#123;</span><br><span class="line">        skipAnnotation(buf, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">AnnotationType</span> <span class="variable">type</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 根据刚刚找到的注解类建立 AnnotationType 的实例（反射对象）。</span></span><br><span class="line">        <span class="comment">// 对于这个方法的分析详见 “AnnotationType 反射对象的建立”。</span></span><br><span class="line">        <span class="comment">// 这个类的主要作用是用来保存这个注解的共有信息的。</span></span><br><span class="line">        type = AnnotationType.getInstance(annotationClass);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        skipAnnotation(buf, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据刚刚建立的 AnnotationType 的实例填充有关信息。</span></span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; memberTypes = type.memberTypes();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这会在生成一个 LinkedHashMap 的同时把默认值给填充进来。</span></span><br><span class="line">    Map&lt;String, Object&gt; memberValues =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;String, Object&gt;(type.memberDefaults());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取键值对属性的个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numMembers</span> <span class="operator">=</span> buf.getShort() &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numMembers; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">memberNameIndex</span> <span class="operator">=</span> buf.getShort() &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">        <span class="comment">// 从常量池当中取得属性名及其它的类型。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">memberName</span> <span class="operator">=</span> constPool.getUTF8At(memberNameIndex);</span><br><span class="line">        Class&lt;?&gt; memberType = memberTypes.get(memberName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (memberType == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Member is no longer present in annotation type; ignore it</span></span><br><span class="line">            skipMemberValue(buf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 获取属性值。详见 “注解属性值的获取”</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> parseMemberValue(memberType, buf, constPool, container);</span><br><span class="line">            <span class="keyword">if</span> (value <span class="keyword">instanceof</span> AnnotationTypeMismatchExceptionProxy)</span><br><span class="line">                ((AnnotationTypeMismatchExceptionProxy) value).</span><br><span class="line">                setMember(type.members().get(memberName));</span><br><span class="line">            memberValues.put(memberName, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将刚刚获取到的属性值组装成注解接口的代理对象</span></span><br><span class="line">    <span class="comment">// 并包装为一个 Map 集合。</span></span><br><span class="line">    <span class="comment">// 详见 “注解的运行时对象的生成”</span></span><br><span class="line">    <span class="keyword">return</span> annotationForMap(annotationClass, memberValues);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="注解属性值的获取-AnnotationParser-parseMemberValue"><a href="#注解属性值的获取-AnnotationParser-parseMemberValue" class="headerlink" title="注解属性值的获取 - AnnotationParser.parseMemberValue"></a>注解属性值的获取 - AnnotationParser.parseMemberValue</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">parseMemberValue</span><span class="params">(Class&lt;?&gt; memberType,</span></span><br><span class="line"><span class="params">                                          ByteBuffer buf,</span></span><br><span class="line"><span class="params">                                          ConstantPool constPool,</span></span><br><span class="line"><span class="params">                                          Class&lt;?&gt; container)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tag</span> <span class="operator">=</span> buf.get();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据对应 tag 进行不同类型属性值的获取。</span></span><br><span class="line">    <span class="comment">// 但是基本上就是根据常量池和序号引用，并调用获取不同类别的实例进行操作。</span></span><br><span class="line">    <span class="comment">// 具体的类型在 class 文件的存储办法可以参考 JVMS </span></span><br><span class="line">    <span class="keyword">switch</span>(tag) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">            <span class="comment">// 调用了 Enum.valueOf(enumType, constName);</span></span><br><span class="line">            <span class="keyword">return</span> parseEnumValue((Class&lt;? <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;?&gt;&gt;)memberType, buf, constPool, container);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">            result = parseClassValue(buf, constPool, container);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;@&#x27;</span>:</span><br><span class="line">            result = parseAnnotation(buf, constPool, container, <span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;[&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> parseArray(memberType, buf, constPool, container);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            result = parseConst(tag, buf, constPool);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(result <span class="keyword">instanceof</span> ExceptionProxy) &amp;&amp;</span><br><span class="line">        !memberType.isInstance(result))</span><br><span class="line">        result = <span class="keyword">new</span> <span class="title class_">AnnotationTypeMismatchExceptionProxy</span>(</span><br><span class="line">        result.getClass() + <span class="string">&quot;[&quot;</span> + result + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="AnnotationType-反射对象的建立-5"><a href="#AnnotationType-反射对象的建立-5" class="headerlink" title="AnnotationType 反射对象的建立 [5]"></a>AnnotationType 反射对象的建立 [5]</h3><p>根据上文，AnnotationType 的主要作用是用来保存这个注解的共有信息的。比如这个注解属性的键。</p>
<h4 id="getInstance-工厂方法"><a href="#getInstance-工厂方法" class="headerlink" title="getInstance() 工厂方法"></a>getInstance() 工厂方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> AnnotationType <span class="title function_">getInstance</span><span class="params">(</span></span><br><span class="line"><span class="params">    Class&lt;? extends Annotation&gt; annotationClass)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        下面两行相当于：</span></span><br><span class="line"><span class="comment">            var result = annotationClass.getAnnotationType();</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">        具体设计的原因详见备注 2</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">JavaLangAccess</span> <span class="variable">jla</span> <span class="operator">=</span> SharedSecrets.getJavaLangAccess();</span><br><span class="line">    <span class="comment">// 根据对 Class 类的分析，AnnotationType 类是有缓存的。</span></span><br><span class="line">    <span class="type">AnnotationType</span> <span class="variable">result</span> <span class="operator">=</span> jla.getAnnotationType(annotationClass); <span class="comment">// volatile read</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 如果没缓存</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 先自己建一个</span></span><br><span class="line">        result = <span class="keyword">new</span> <span class="title class_">AnnotationType</span>(annotationClass);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// try to CAS the AnnotationType: null -&gt; result</span></span><br><span class="line">        <span class="comment">// CAS = Compare And Swap</span></span><br><span class="line">        <span class="comment">// 其相当于 annotationClass.casAnnotationType(null, result);</span></span><br><span class="line">        <span class="comment">// 这是通过 CAS 确保只有一个线程修改 annotationType 变量</span></span><br><span class="line">        <span class="keyword">if</span> (!jla.casAnnotationType(annotationClass, <span class="literal">null</span>, result)) &#123;</span><br><span class="line">            <span class="comment">// somebody was quicker -&gt; read it&#x27;s result</span></span><br><span class="line">            <span class="comment">// 如上述注释。如果有线程修改好了就用它的结果。</span></span><br><span class="line">            result = jla.getAnnotationType(annotationClass);</span><br><span class="line">            <span class="keyword">assert</span> result != <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="AnnotationType-的私有构造器"><a href="#AnnotationType-的私有构造器" class="headerlink" title="AnnotationType 的私有构造器"></a>AnnotationType 的私有构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">AnnotationType</span><span class="params">(<span class="keyword">final</span> Class&lt;? extends Annotation&gt; annotationClass)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!annotationClass.isAnnotation())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Not an annotation type&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Method[] methods =</span><br><span class="line">        AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> Method[] run() &#123;</span><br><span class="line">                <span class="comment">// Initialize memberTypes and defaultValues</span></span><br><span class="line">                <span class="comment">// 获取注解 “接口” 的 “方法” （其实就是 “键”）</span></span><br><span class="line">                <span class="keyword">return</span> annotationClass.getDeclaredMethods();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    memberTypes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(methods.length+<span class="number">1</span>, <span class="number">1.0f</span>);</span><br><span class="line">    memberDefaults = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">0</span>);</span><br><span class="line">    members = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(methods.length+<span class="number">1</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Modifier.isPublic(method.getModifiers()) &amp;&amp;</span><br><span class="line">            Modifier.isAbstract(method.getModifiers()) &amp;&amp;</span><br><span class="line">            !method.isSynthetic()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (method.getParameterCount() != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(method + <span class="string">&quot; has params&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取键</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> method.getName();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取值的类型</span></span><br><span class="line">            Class&lt;?&gt; type = method.getReturnType();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// invocationHandlerReturnType 主要是将</span></span><br><span class="line">            <span class="comment">// 基本数据类型的 class 对象转化包装类型的 class 对象</span></span><br><span class="line">            memberTypes.put(name, invocationHandlerReturnType(type));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将方法的名字和它对应的 Method 放到 members 表当中。</span></span><br><span class="line">            members.put(name, method);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取默认值 （即 default 字句）</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">defaultValue</span> <span class="operator">=</span> method.getDefaultValue();</span><br><span class="line">            <span class="keyword">if</span> (defaultValue != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 放入默认值表</span></span><br><span class="line">                memberDefaults.put(name, defaultValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize retention, &amp; inherited fields.  Special treatment</span></span><br><span class="line">    <span class="comment">// of the corresponding annotation types breaks infinite recursion.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理元注解。</span></span><br><span class="line">    <span class="keyword">if</span> (annotationClass != Retention.class &amp;&amp;</span><br><span class="line">        annotationClass != Inherited.class) &#123;</span><br><span class="line">        <span class="type">JavaLangAccess</span> <span class="variable">jla</span> <span class="operator">=</span> SharedSecrets.getJavaLangAccess();</span><br><span class="line">        Map&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;, Annotation&gt; metaAnnotations =</span><br><span class="line">            AnnotationParser.parseSelectAnnotations(</span><br><span class="line">            jla.getRawClassAnnotations(annotationClass),</span><br><span class="line">            jla.getConstantPool(annotationClass),</span><br><span class="line">            annotationClass,</span><br><span class="line">            Retention.class, Inherited.class</span><br><span class="line">        );</span><br><span class="line">        <span class="type">Retention</span> <span class="variable">ret</span> <span class="operator">=</span> (Retention) metaAnnotations.get(Retention.class);</span><br><span class="line">        retention = (ret == <span class="literal">null</span> ? RetentionPolicy.CLASS : ret.value());</span><br><span class="line">        inherited = metaAnnotations.containsKey(Inherited.class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        retention = RetentionPolicy.RUNTIME;</span><br><span class="line">        inherited = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="注解的运行时对象（动态代理对象）的生成"><a href="#注解的运行时对象（动态代理对象）的生成" class="headerlink" title="注解的运行时对象（动态代理对象）的生成"></a>注解的运行时对象（动态代理对象）的生成</h2><p>根据上文对注解的分析，我们知道注解是一种特殊的接口。既然是接口，那么肯定就要有接口的实现。根据刚刚的分析，我们可以知道注解的运行时类型是一个动态代理对象。在分析注解的动态代理对象的具体行为之前，我们先来回顾一下动态代理。</p>
<h3 id="动态代理的回顾"><a href="#动态代理的回顾" class="headerlink" title="动态代理的回顾"></a>动态代理的回顾</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ac.testproj.invoke;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 封装动态代理对象的调用行为。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Andy Cheung</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Invoking method: &quot;</span> + method.getName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (method.getName()) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;hashCode&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">super</span>.hashCode();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;equals&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">super</span>.equals(args[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;toString&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">super</span>.toString();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (method.getParameterCount() != <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Received a number: &quot;</span> + args[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> ((Integer) args[<span class="number">0</span>]) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对外提供调用方法的接口。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Andy Cheung </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Action</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">act1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">act2</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">act3</span><span class="params">(<span class="type">int</span> val)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Andy Cheung</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestInvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 让动态代理机制写入生成的中间 class 文件到硬盘。[6]</span></span><br><span class="line">        System.getProperties().put(<span class="string">&quot;jdk.proxy.ProxyGenerator.saveGeneratedFiles&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个基于 Action 接口的动态代理类。</span></span><br><span class="line">        <span class="comment">// 参数：类加载器，要实现的接口，InvocationHandler 的实例</span></span><br><span class="line">        <span class="type">var</span> <span class="variable">proxy</span> <span class="operator">=</span> (Action) Proxy.newProxyInstance(TestInvocationHandler.class.getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;Action.class&#125;, <span class="keyword">new</span> <span class="title class_">MyInvocationHandler</span>());</span><br><span class="line"></span><br><span class="line">        proxy.act1();</span><br><span class="line">        proxy.act2();</span><br><span class="line">        System.out.println(<span class="string">&quot;Got Return in act3: &quot;</span> + proxy.act3(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(proxy.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br />

<p>输出如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Invoking method: act1</span><br><span class="line">Invoking method: act2</span><br><span class="line">Invoking method: act3</span><br><span class="line">Received a number: <span class="number">1</span></span><br><span class="line">Got Return in act3: <span class="number">2</span></span><br><span class="line">ac.testproj.invoke.$Proxy0</span><br></pre></td></tr></table></figure>



<p>运行后工作目录出现了生成的 class 文件：</p>
<p><img src="/2021/01/27/what-happened-on-annotations/generatedFile.png" alt="Generated proxy class file [Fig. (Sect. Proxy) 1, 20210208]"></p>
<p>经过反编译，发现生成的代码如下（节选部分且顺序经过调整）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ac.testproj.invoke;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">extends</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">Action</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m4;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m5;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m0 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;hashCode&quot;</span>);</span><br><span class="line">            m1 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>)</span><br><span class="line">                .getMethod(<span class="string">&quot;equals&quot;</span>, Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;toString&quot;</span>);</span><br><span class="line">            m3 = Class.forName(<span class="string">&quot;ac.testproj.invoke.Action&quot;</span>).getMethod(<span class="string">&quot;act3&quot;</span>, Integer.TYPE);</span><br><span class="line">            m4 = Class.forName(<span class="string">&quot;ac.testproj.invoke.Action&quot;</span>).getMethod(<span class="string">&quot;act2&quot;</span>);</span><br><span class="line">            m5 = Class.forName(<span class="string">&quot;ac.testproj.invoke.Action&quot;</span>).getMethod(<span class="string">&quot;act1&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchMethodError</span>(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoClassDefFoundError</span>(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler param1) &#123;</span><br><span class="line">        <span class="built_in">super</span>(param1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">act3</span><span class="params">(<span class="type">int</span> var1)</span> &#123;</span><br><span class="line">        <span class="comment">// super.h 就是我们指定的 InvocationHandler。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m3, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">act2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m4, (Object[])<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">act1</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object var1)</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>根据生成的中间代码我们可以看出，动态代理实际上是在内存中（如果没有指定保存到硬盘上的话）生成一个中间代理类，这个代理类继承了 Proxy 类，并实现了我们指定的接口和 Serializable 接口（由 Proxy 类实现）。其将所有的方法（包括我们指定的接口以及 Object 类的方法）委托给传入的 InvocationHandler。由此证实 InvocationHandler 封装了动态代理类的行为。</p>
<h3 id="注解的动态代理对象的建立"><a href="#注解的动态代理对象的建立" class="headerlink" title="注解的动态代理对象的建立"></a>注解的动态代理对象的建立</h3><p>来到 annotationforMap 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建立（刚刚识别的） Annotation 的动态代理对象。 </span></span><br><span class="line"><span class="comment">// 参数列表：(注解的 Class 对象，属性值)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Annotation <span class="title function_">annotationForMap</span><span class="params">(<span class="keyword">final</span> Class&lt;? extends Annotation&gt; type,</span></span><br><span class="line"><span class="params">                                          <span class="keyword">final</span> Map&lt;String, Object&gt; memberValues)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Annotation&gt;() &#123;</span><br><span class="line">        <span class="keyword">public</span> Annotation <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 根据这个注解的类型和它的属性值生成了目标接口的一个代理类对象。</span></span><br><span class="line">            <span class="keyword">return</span> (Annotation) Proxy.newProxyInstance(</span><br><span class="line">                type.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123; type &#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">AnnotationInvocationHandler</span>(type, memberValues));</span><br><span class="line">        &#125;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>由此可见注解的方法调用的有关行为都交给了 AnnotationInvocationHandler 这一 InvocationHandler （行为封装）。</p>
<h2 id="注解的动态代理对象行为的分析"><a href="#注解的动态代理对象行为的分析" class="headerlink" title="注解的动态代理对象行为的分析"></a>注解的动态代理对象行为的分析</h2><p>根据上述信息，我们来到 AnnotationInvocationHandler 这个类 [7]。</p>
<p>首先来看下这个类的结构。</p>
<p><img src="/2021/01/27/what-happened-on-annotations/invocationHandler1.png"></p>
<p><img src="/2021/01/27/what-happened-on-annotations/invocationHandler2.png" alt="Structure of AnnotationInvocationHandler"></p>
<p>我们可以看见有很多的方法（主要是 hashCode 等方法的实现）下面我们来逐一分析。</p>
<h3 id="动态代理对象总的行为-invoke-方法"><a href="#动态代理对象总的行为-invoke-方法" class="headerlink" title="动态代理对象总的行为 - invoke 方法"></a>动态代理对象总的行为 - invoke 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 方法名和方法参数的个数</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">member</span> <span class="operator">=</span> method.getName();</span><br><span class="line">    <span class="type">int</span> <span class="variable">parameterCount</span> <span class="operator">=</span> method.getParameterCount();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle Object and Annotation methods - Object 定义的方法和 Annotation 的方法</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// equals(Object)</span></span><br><span class="line">    <span class="keyword">if</span> (parameterCount == <span class="number">1</span> &amp;&amp; member == <span class="string">&quot;equals&quot;</span> &amp;&amp;</span><br><span class="line">        method.getParameterTypes()[<span class="number">0</span>] == Object.class) &#123;</span><br><span class="line">        <span class="keyword">return</span> equalsImpl(proxy, args[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (parameterCount != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(<span class="string">&quot;Too many parameters for an annotation method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (member == <span class="string">&quot;toString&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// toString() 方法</span></span><br><span class="line">        <span class="keyword">return</span> toStringImpl();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (member == <span class="string">&quot;hashCode&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// hashCode() 方法</span></span><br><span class="line">        <span class="keyword">return</span> hashCodeImpl();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (member == <span class="string">&quot;annotationType&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// annotationType() 方法</span></span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle annotation member accessors</span></span><br><span class="line">    <span class="comment">// 我们定义的注解的属性</span></span><br><span class="line">    <span class="comment">// 根据我们从 AnnotationParser 获取到的属性值，来返回最终的值。</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> memberValues.get(member);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IncompleteAnnotationException</span>(type, member);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result <span class="keyword">instanceof</span> ExceptionProxy)</span><br><span class="line">        <span class="keyword">throw</span> ((ExceptionProxy) result).generateException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了防止数组被修改，先复制出来再返回</span></span><br><span class="line">    <span class="keyword">if</span> (result.getClass().isArray() &amp;&amp; Array.getLength(result) != <span class="number">0</span>)</span><br><span class="line">        result = cloneArray(result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="hashCode-方法的实现-hashCodeImpl"><a href="#hashCode-方法的实现-hashCodeImpl" class="headerlink" title="hashCode 方法的实现 - hashCodeImpl()"></a>hashCode 方法的实现 - hashCodeImpl()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">hashCodeImpl</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 对每一个属性进行 hash 运算。</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; e : memberValues.entrySet()) &#123;</span><br><span class="line">        result += (<span class="number">127</span> * e.getKey().hashCode()) ^</span><br><span class="line">            memberValueHashCode(e.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们发现 result +&#x3D; … 的这句话的做法非常像 HashMap 的 hash 方法 [8]：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Computes key.hashCode() and spreads (XORs) higher bits of hash</span></span><br><span class="line"><span class="comment"> * to lower.  Because the table uses power-of-two masking, sets of</span></span><br><span class="line"><span class="comment"> * hashes that vary only in bits above the current mask will</span></span><br><span class="line"><span class="comment"> * always collide. (Among known examples are sets of Float keys</span></span><br><span class="line"><span class="comment"> * holding consecutive whole numbers in small tables.)  So we</span></span><br><span class="line"><span class="comment"> * apply a transform that spreads the impact of higher bits</span></span><br><span class="line"><span class="comment"> * downward. There is a tradeoff between speed, utility, and</span></span><br><span class="line"><span class="comment"> * quality of bit-spreading. Because many common sets of hashes</span></span><br><span class="line"><span class="comment"> * are already reasonably distributed (so don&#x27;t benefit from</span></span><br><span class="line"><span class="comment"> * spreading), and because we use trees to handle large sets of</span></span><br><span class="line"><span class="comment"> * collisions in bins, we just XOR some shifted bits in the</span></span><br><span class="line"><span class="comment"> * cheapest possible way to reduce systematic lossage, as well as</span></span><br><span class="line"><span class="comment"> * to incorporate impact of the highest bits that would otherwise</span></span><br><span class="line"><span class="comment"> * never be used in index calculations because of table bounds.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>hash 方法主要是通过将高 16 位无符号右移 16 位跟低 16 位对齐，并对低 16 位进行异或操作（用异或的原因见备注 3）。这个操作的主要目的是减缓在某些情况下的 hash 冲突。</p>
<p>而注解的 hashCodeImpl 的意图是对键值对的 hash 值进行均匀混合。</p>
<h3 id="equals-方法的实现-equalsImpl-Object-Object"><a href="#equals-方法的实现-equalsImpl-Object-Object" class="headerlink" title="equals 方法的实现 - equalsImpl(Object, Object)"></a>equals 方法的实现 - equalsImpl(Object, Object)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// proxy = 代理对象自身</span></span><br><span class="line"><span class="comment">// o = 要比较的对象</span></span><br><span class="line"><span class="keyword">private</span> Boolean <span class="title function_">equalsImpl</span><span class="params">(Object proxy, Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == proxy)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 看 o 是不是这个注解“接口”的实例（是不是这个注释的代理对象）。</span></span><br><span class="line">    <span class="comment">// 相当于 if (!(o instanceof &lt;type 的类型&gt;))</span></span><br><span class="line">    <span class="keyword">if</span> (!type.isInstance(o))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 属性值挨个比对，所有值相等才判 true</span></span><br><span class="line">    <span class="keyword">for</span> (Method memberMethod : getMemberMethods()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">member</span> <span class="operator">=</span> memberMethod.getName();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">ourValue</span> <span class="operator">=</span> memberValues.get(member);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">hisValue</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 判定是不是 AnnotationInvocationHandler 的实例，如果是的话，返回转换成它之后的对象</span></span><br><span class="line">        <span class="type">AnnotationInvocationHandler</span> <span class="variable">hisHandler</span> <span class="operator">=</span> asOneOfUs(o);</span><br><span class="line">        <span class="keyword">if</span> (hisHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">            hisValue = hisHandler.memberValues.get(member);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                hisValue = memberMethod.invoke(o);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 根据数据类型进行相等比较</span></span><br><span class="line">        <span class="keyword">if</span> (!memberValueEquals(ourValue, hisValue))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="本文所提到有关注解的-Java-标准库的-UML-图"><a href="#本文所提到有关注解的-Java-标准库的-UML-图" class="headerlink" title="本文所提到有关注解的 Java 标准库的 UML 图"></a>本文所提到有关注解的 Java 标准库的 UML 图</h2><p><img src="/2021/01/27/what-happened-on-annotations/uml.png" alt="UML Diagram of annotation-related classes in API of Java"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>注解本身在 class 文件上来看是一种特殊的接口，它的 “实现” 由动态代理和 AnnotationInvocationHandler 给予。</li>
<li>实际上使用注解的时候注解的有关信息是存在 class 文件被修饰元素部分的 Runtime(In)visibleAnnotations 的属性表里头的。</li>
<li>注解的解析逻辑在 sun.reflect.annotation.AnnotationParser 里头。</li>
<li>注解在运行时的对象是由动态代理产生的，其行为封装在 sun.reflect.annotation.AnnotationInvocationHandler 类里头，实现了被解析的注解这一 “接口” 。</li>
<li>注解本身在运行时里头也有个代表它本身，且用来存储共同信息的对象 sun.reflect.annotation.AnnotationType</li>
</ol>
<hr>
<p>备注：</p>
<ol>
<li><p>使用 Oracle OpenJDK 15 编译，并启动了预览功能。</p>
</li>
<li><p>SharedSecrets 以及一系列 Access 结尾的接口主要是为了能让内部实现包（即不是 java 和 javax 开头的那些包）能够不使用反射地访问到 java 和 javax 的包当中没有公开的方法（即包访问控制符的那些方法）。这些接口的实现比较分散，但是几乎都是在某个类的一个方法中调用 SharedSecrets.setXXXAccess （并传入一个匿名内部类）。比如 JavaLangAccess 的实现在 System 类的 setJavaLangAccess() 当中的一个匿名内部类。这解决了访问控制符的语法规定和内部实现类跨包访问的矛盾。</p>
</li>
<li><p>进行异或操作的主要原因是它产生的结果的概率是相等的。</p>
<p>因为根据真值表：</p>
<table>
<thead>
<tr>
<th align="center">X</th>
<th align="center">Y</th>
<th align="center">输出 (X ^ Y)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p>P (X ^ Y &#x3D; 1) &#x3D; 2 &#x2F; 4 &#x3D; 1 &#x2F; 2</p>
<p>P (X ^ Y &#x3D; 0) &#x3D; 2 &#x2F; 4 &#x3D; 1 &#x2F; 2</p>
<p>两者相等。</p>
</li>
</ol>
<hr>
<p>引用和参考：</p>
<style>
    small p {
        color : grey;
        line-height : 1em !important;
    }
</style>


<small>

<p>[1] The Java Virtual Machine Specification, Java SE 15 Edition</p>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se15/jvms15.pdf">https://docs.oracle.com/javase/specs/jvms/se15/jvms15.pdf</a></p>
<p>[2] openJDK - com.sun.tools.javac.jvm.ClassWriter</p>
<p><a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk15/blob/master/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/ClassWriter.java">https://github.com/openjdk/jdk15/blob/master/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/ClassWriter.java</a></p>
<p>[3] openJDK - java.lang.reflect.Field</p>
<p><a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk15/blob/master/src/java.base/share/classes/java/lang/reflect/Field.java">https://github.com/openjdk/jdk15/blob/master/src/java.base/share/classes/java/lang/reflect/Field.java</a></p>
<p>[4] openJDK - sun.reflect.annotation.AnnotationParser</p>
<p><a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk15/blob/master/src/java.base/share/classes/sun/reflect/annotation/AnnotationParser.java">https://github.com/openjdk/jdk15/blob/master/src/java.base/share/classes/sun/reflect/annotation/AnnotationParser.java</a></p>
<p>[5] openJDK - sun.reflect.annotation.AnnotationType</p>
<p><a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk15/blob/master/src/java.base/share/classes/sun/reflect/annotation/AnnotationType.java">https://github.com/openjdk/jdk15/blob/master/src/java.base/share/classes/sun/reflect/annotation/AnnotationType.java</a></p>
<p>[6] JDK动态代理生成的class文件保存到本地失败问题（sun.misc.ProxyGenerator.saveGeneratedFiles）</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zyq8514700/article/details/99892329">https://blog.csdn.net/zyq8514700/article/details/99892329</a></p>
<p>[7] openJDK - sun.reflect.annotation.AnnotationInvocationHandler</p>
<p><a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk15/blob/master/src/java.base/share/classes/sun/reflect/annotation/AnnotationInvocationHandler.java">https://github.com/openjdk/jdk15/blob/master/src/java.base/share/classes/sun/reflect/annotation/AnnotationInvocationHandler.java</a></p>
<p>[8] openJDK - java.util.HashMap</p>
<p><a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk15/blob/master/src/java.base/share/classes/java/util/HashMap.java">https://github.com/openjdk/jdk15/blob/master/src/java.base/share/classes/java/util/HashMap.java</a></p>
</small>

<hr />

<p>[ TART - JDK - T2 - Y21 (1) ] @HQ</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://win120a.github.io/2021/01/27/what-happened-on-annotations/" data-id="cly2lczyz0003e7py917zaus6" data-title="源码探索 | 从 Java 层面分析注解 (Annotation) 从编译到运行时发生了什么" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OpenJDK-%E5%BA%95%E5%B1%82%E6%8E%A2%E7%A9%B6/" rel="tag">OpenJDK 底层探究</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-tomcat-jndi" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/06/09/tomcat-jndi/" class="article-date">
  <time class="dt-published" datetime="2020-06-09T16:00:00.000Z" itemprop="datePublished">2020-06-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/06/09/tomcat-jndi/">Tomcat 下通过 JNDI 获取绑定的数据源对象的背后原理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>重温一下我们在程序中使用 JNDI 配置的数据源的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InitialContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">DataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ctx = <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">    ds = (DataSource) ctx.lookup(<span class="string">&quot;java:comp/env/jdbc/eduDS&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NamingException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> ds.getConnection()) &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>JNDI 是 Java 的一个组件。它是一个通过名字取得对象的一个接口。Tomcat 提供了它的其中一种实现，下面我们不妨来简单分析下这其中的原理。</p>
<h1 id="0-JNDI-的一些概念"><a href="#0-JNDI-的一些概念" class="headerlink" title="0. JNDI 的一些概念"></a>0. JNDI 的一些概念</h1><p>在研究这一系列原理之前，我们先认识一下 JNDI 和它的几个对象。</p>
<h2 id="JNDI-的概念与设计思想"><a href="#JNDI-的概念与设计思想" class="headerlink" title="JNDI 的概念与设计思想"></a>JNDI 的概念与设计思想</h2><p>JNDI 是 Java 命名与目录服务接口的英文简称。它主要是定义一批在 Java 的有关命名 &#x2F; 目录服务的一系列接口（API &#x2F; SPI）。JNDI 的结构设计与 JDBC 相仿，都是把对外接口 （API） 与具体实现 （SPI，在 JDBC 中叫驱动程序） 分离。</p>
<h2 id="JNDI-在-JDK-中的位置"><a href="#JNDI-在-JDK-中的位置" class="headerlink" title="JNDI 在 JDK 中的位置"></a>JNDI 在 JDK 中的位置</h2><p>JNDI 的相关类和接口均位于 java.naming 模块的各个包中。其中我们主要操作的类在 javax.naming 这个包中。</p>
<h2 id="JNDI-的几个常见对象"><a href="#JNDI-的几个常见对象" class="headerlink" title="JNDI 的几个常见对象"></a>JNDI 的几个常见对象</h2><p>(a)  <code>javax.naming.Context</code> 接口：在 JNDI 中表示一组绑定关系。</p>
<p>(b)  <code>javax.naming.InitialContext</code> 类： JNDI 一系列操作的入口类，它更多的扮演着委托代理类的角色，把我们对这个类的调用“转发” 到实际指定的 Context 的实现类。</p>
<p>(c)  <code>javax.naming.Name</code> 接口：代表命名服务中的“名字”。常见的实现类有 <code>CompositeName</code>。</p>
<h1 id="1-InitialContext-的工作流程"><a href="#1-InitialContext-的工作流程" class="headerlink" title="1. InitialContext 的工作流程"></a>1. InitialContext 的工作流程</h1><p>InitialContext 是 JNDI 的一系列的操作的入口类，下面我们先分析下这个类的原理。</p>
<p>①  调用构造器时，InitialContext 所做的事情（点开看大图）：</p>
<p><img src="/2020/06/09/tomcat-jndi/1.png"></p>
<p><img src="/2020/06/09/tomcat-jndi/2.png"></p>
<p>②  调用 lookup 等 Context 接口定义的方法时，实际上发生的事情：</p>
<p><img src="/2020/06/09/tomcat-jndi/3.png"></p>
<p>我们可以看出，这主要是先判断这是不是一个 URL Context，然后再根据情况调用不同的方法。这调用了 InitialContext 的 getURLScheme 方法。</p>
<p><img src="/2020/06/09/tomcat-jndi/getURLScheme.png"></p>
<p>这段代码的意思是：如果有地址符合类似于“XX:XX&#x2F;XX” 这样的形式的话，那么这是一个 URL Context。前言中的 “java:comp&#x2F;env&#x2F;jdbc&#x2F;eduDS” 显然符合这种形式。那么 NamingManager 的 getURLContext 会被调用。</p>
<p><img src="/2020/06/09/tomcat-jndi/getURLContext.png"></p>
<p>我们不难看出它实际上是调用了 getURLObject 方法。</p>
<p><img src="/2020/06/09/tomcat-jndi/getURLObject.png"></p>
<p>它通过获取 Context.URL_PKG_PREFIXES 所对应的系统属性的值，来查找对应的工厂类，并创建它的实例（也会缓存）。根据 NamingManger 的文档综合整理可知：</p>
<p><code>ResouceManager.getObjectInstance</code> 方法会根据 <code>Context.URL_PKG_PREFIXES</code> 对应的系统属性的值挨个查找对应 scheme 的类。而其是一个以冒号分隔开的属性，用于指定要查找的包。</p>
<p>它查找的类符合这个规律：</p>
<p>​	<code>&#123;其中一个包名&#125;.&#123;scheme&#125;.&#123;scheme&#125;URLContextFactory</code></p>
<p>而 java 这个 scheme 对应的正好就是</p>
<p>​	 <code>xx.java.javaURLContextFactory</code> </p>
<p>又因 <code>Context.URL_PKG_PREFIXES</code> 对应的系统属性给指定成了</p>
<p>​	<code>org.apache.naming</code></p>
<p>于是 <code>org.apache.naming.java.javaURLContextFactory</code> 就给匹配上了。</p>
<p>从上面的代码可以证实，InitialContext 更多地是充当了一个委托代理的角色，把方法调用 “转发” 给实际指定的 Context 实现。</p>
<h1 id="2-Tomcat-对-InitialContext-的实际实现原理"><a href="#2-Tomcat-对-InitialContext-的实际实现原理" class="headerlink" title="2. Tomcat 对 InitialContext 的实际实现原理"></a>2. Tomcat 对 InitialContext 的实际实现原理</h1><p>根据上文可知，在 Tomcat 中，<code>InitialContext</code> 的实际操作对象是 <code>org.apache.naming.java.javaURLContextFactory</code> 类。下面是这个类的 <code>getInitialContext</code> 方法的源代码：</p>
<p><img src="/2020/06/09/tomcat-jndi/getInitialContext.png"></p>
<p>这段代码会使用 <code>ContextBindings</code> 来检查线程 &#x2F; 类加载器是否绑定了一个 Context，来返回不同的 Context 实现类。下面是 <code>ContextBindings.isClassLoaderBound</code> 方法：</p>
<p><img src="/2020/06/09/tomcat-jndi/isClassLoaderBound.png"></p>
<p>可以知道它实际上会检查这个类的 <code>clBindings</code> 集合是否含有这个线程的 <code>ContextClassLoader</code> 以及它的上级类加载器。根据对 <code>clBindings</code>  （每个应用一个 <code>ParallelWebAppClassLoader</code>） 和 <code>threadBindings</code> （没有元素）的探究，我们发现可以看出它实际上返回的是 <code>SelectorContext</code> 对象。</p>
<p><img src="/2020/06/09/tomcat-jndi/4.png"></p>
<p>对 <code>InitialContext</code> 的 <code>defaultInitCtx</code> （缓存的 Context）也证实了这一点。</p>
<p><img src="/2020/06/09/tomcat-jndi/selectorCtx.png"></p>
<p>对 <code>ContextBindings</code> 进行分析可知它是 Tomcat 中管理类选择器 &#x2F; 线程与 Context 绑定关系的类。（篇幅有限，不放出它的源代码）。这个类主要使用 Map 来保存它们之间的关系。</p>
<p>对 <code>SelectorContext.lookup</code> 方法进行分析可以知道它实际上是调用了 <code>getBoundContext</code> 方法，源代码如下：</p>
<p><img src="/2020/06/09/tomcat-jndi/5.png"></p>
<p>现在对于绑定的 Context 类型，就有了两种情况：</p>
<h2 id="1-直接在-InitialContext-对应绑定的-Context"><a href="#1-直接在-InitialContext-对应绑定的-Context" class="headerlink" title="1. 直接在 InitialContext 对应绑定的 Context"></a>1. 直接在 InitialContext 对应绑定的 Context</h2><p>Tomcat 会做特殊标识，并在 <code>ContextBindings</code> 中注册。这个情况主要的作用是保存直接在 <code>InitialContext</code> 中绑定的关系。因为和主题关系不大，故不讲。</p>
<h2 id="2-URL-Context-等非直接绑定到-InitialContext-的-Context"><a href="#2-URL-Context-等非直接绑定到-InitialContext-的-Context" class="headerlink" title="2. URL Context 等非直接绑定到 InitialContext 的 Context"></a>2. URL Context 等非直接绑定到 InitialContext 的 Context</h2><p>我们发现其实它是从 ContextBindings 中获取这个类加载器 &#x2F; 线程对应的 Context。经查询，发现其对应的 Context 是 NamingContext。</p>
<p><img src="/2020/06/09/tomcat-jndi/getClassLoader-Eval.png"></p>
<p>根据 bindings 的提示，我们可以看到 “comp&#x2F;env&#x2F;…” 的树状结构了。这时候我们发现，每一个 bindings 的某一项的值就是一个 NamingEntry 的实例。NamingEntry 是一个数据类，代码就不放出来了。另外，如果是一个子 Context，那么这些都是 NamingContext 的实例。</p>
<p>我们还是分析一下这个类的 lookup 方法。首先 <code>NamingContext.lookup</code> 方法的 (String) 重载方法会先把 name 包装成 CompositeName 对象，之后调用 (Name) 的重载方法，之后再调用 (Name, boolean) 的重载方法，这一重载方法的部分源代码如下：</p>
<p><img src="/2020/06/09/tomcat-jndi/naming-lookup.png"></p>
<p>这个重载方法首先通过 CompositeName 的 size 方法判断是否有多个子节点，如果有多个子节点就使用递归把子节点所对应的 Context 给获取到。之后根据数据类 NamingEntry 的 type 属性，来返回不同的值。根据 NamingEntry 的定义，type 为 0 时，这代表 ENTRY （节点）。而我们的数据源就属于此类，因此直接返回对应 NamingEntry 的 value 属性，结束。</p>
<p> <img src="/2020/06/09/tomcat-jndi/typ0.png"></p>
<hr>
<p>参考代码：</p>
<style>
    small p {
        color : grey;
        line-height : 1em !important;
    }
</style>



<small>

<p>[1] openJDK</p>
<p><a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk14">https://github.com/openjdk/jdk14</a></p>
<p>[2] tomcat (9.0.x)</p>
<p><a target="_blank" rel="noopener" href="https://github.com/apache/tomcat/tree/9.0.x">https://github.com/apache/tomcat/tree/9.0.x</a></p>
</small>

<hr />

<p>[ TART - TC - T1 - Y20 (1) ] @HQ</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://win120a.github.io/2020/06/09/tomcat-jndi/" data-id="cly2lczyt0000e7py8cike51s" data-title="Tomcat 下通过 JNDI 获取绑定的数据源对象的背后原理" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Tomcat-%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/" rel="tag">Tomcat 原理探究</a></li></ul>

    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Apache-Dubbo/" rel="tag">Apache Dubbo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dubbo-ECI/" rel="tag">Dubbo ECI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Javassist/" rel="tag">Javassist</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OpenJDK-%E5%BA%95%E5%B1%82%E6%8E%A2%E7%A9%B6/" rel="tag">OpenJDK 底层探究</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tomcat-%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/" rel="tag">Tomcat 原理探究</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Apache-Dubbo/" style="font-size: 10px;">Apache Dubbo</a> <a href="/tags/Dubbo-ECI/" style="font-size: 10px;">Dubbo ECI</a> <a href="/tags/Javassist/" style="font-size: 10px;">Javassist</a> <a href="/tags/OpenJDK-%E5%BA%95%E5%B1%82%E6%8E%A2%E7%A9%B6/" style="font-size: 10px;">OpenJDK 底层探究</a> <a href="/tags/Tomcat-%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/" style="font-size: 10px;">Tomcat 原理探究</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">五月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/05/19/dubbo-eci-1/">Dubbo 在 CI 中自动检查错误码 Logger 调用的实现（一） - 背景和错误码的获取</a>
          </li>
        
          <li>
            <a href="/2021/01/27/what-happened-on-annotations/">源码探索 | 从 Java 层面分析注解 (Annotation) 从编译到运行时发生了什么</a>
          </li>
        
          <li>
            <a href="/2020/06/09/tomcat-jndi/">Tomcat 下通过 JNDI 获取绑定的数据源对象的背后原理</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner" style="display: flex;justify-content: space-between; align-items: center;">
      <div>
          
          &copy; 2024 Andy Cheung<br>
          Powered by <a href="https://hexo.io/" target="_blank">Hexo</a><br />
          Published with <a target="_blank" rel="noopener" href="https://pages.github.com">GitHub Pages</a>
      </div>
      <div style="text-align: center">
          <img src="/images/wechat_mp.jpg" style="width: 5rem; height: 5rem; ">
          <div>微信公众号：内核实验室</div>
      </div>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>