<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Dubbo 在 CI 中自动检查错误码 Logger 调用的实现（二） - 通过 Javassist 完成 Logger 类的判断 | Andy&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="书接上文。此前讲到了通过常量池结合正则表达式获取所有的错误码。下面主要是判断该如何确定各个类调用的是哪个 Logger，以及如果调用的是 error 和 warn 方法的话，是否正确的使用了带错误码的参数。 判断是否使用正确的日志方法Javap 的输出此文仍以上篇文章的org.apache.dubbo.common.DeprecatedMethodInvocationCounter.onDepre">
<meta property="og:type" content="article">
<meta property="og:title" content="Dubbo 在 CI 中自动检查错误码 Logger 调用的实现（二） - 通过 Javassist 完成 Logger 类的判断">
<meta property="og:url" content="http://win120a.github.io/2025/03/02/dubbo-eci-2/index.html">
<meta property="og:site_name" content="Andy&#39;s Blog">
<meta property="og:description" content="书接上文。此前讲到了通过常量池结合正则表达式获取所有的错误码。下面主要是判断该如何确定各个类调用的是哪个 Logger，以及如果调用的是 error 和 warn 方法的话，是否正确的使用了带错误码的参数。 判断是否使用正确的日志方法Javap 的输出此文仍以上篇文章的org.apache.dubbo.common.DeprecatedMethodInvocationCounter.onDepre">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://win120a.github.io/2025/03/02/dubbo-eci-2/codeIterator-1.png">
<meta property="og:image" content="http://win120a.github.io/2025/03/02/dubbo-eci-2/codeIterator-2.png">
<meta property="og:image" content="http://win120a.github.io/2025/03/02/dubbo-eci-2/invokeinterface_args.png">
<meta property="article:published_time" content="2025-03-02T16:00:00.000Z">
<meta property="article:modified_time" content="2025-08-14T11:44:21.959Z">
<meta property="article:author" content="Andy Cheung">
<meta property="article:tag" content="Apache Dubbo">
<meta property="article:tag" content="Dubbo ECI">
<meta property="article:tag" content="Javassist">
<meta property="article:tag" content="Javap">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://win120a.github.io/2025/03/02/dubbo-eci-2/codeIterator-1.png">
  
    <link rel="alternate" href="/atom.xml" title="Andy's Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="/fonts/source-code-pro/latin.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 7.3.0"></head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Andy&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">-- 内核实验室</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://win120a.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-dubbo-eci-2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/02/dubbo-eci-2/" class="article-date">
  <time class="dt-published" datetime="2025-03-02T16:00:00.000Z" itemprop="datePublished">2025-03-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Dubbo 在 CI 中自动检查错误码 Logger 调用的实现（二） - 通过 Javassist 完成 Logger 类的判断
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>书接上文。此前讲到了通过常量池结合正则表达式获取所有的错误码。下面主要是判断该如何确定各个类调用的是哪个 Logger，以及如果调用的是 error 和 warn 方法的话，是否正确的使用了带错误码的参数。</p>
<h1 id="判断是否使用正确的日志方法"><a href="#判断是否使用正确的日志方法" class="headerlink" title="判断是否使用正确的日志方法"></a>判断是否使用正确的日志方法</h1><h2 id="Javap-的输出"><a href="#Javap-的输出" class="headerlink" title="Javap 的输出"></a>Javap 的输出</h2><p>此文仍以上篇文章的<code>org.apache.dubbo.common.DeprecatedMethodInvocationCounter.onDeprecatedMethodCalled(String)</code> 的输出的节选为例。<small>该类在最近在 Dubbo 的主线被删除，请参考参考链接 <sup>[1]</sup> 中的文件</small>）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">org</span>.apache.dubbo.common.DeprecatedMethodInvocationCounter</span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: (<span class="number">0x0031</span>) ACC_PUBLIC, ACC_FINAL, ACC_SUPER</span><br><span class="line">  this_class: #<span class="number">41</span>                         <span class="comment">// org/apache/dubbo/common/DeprecatedMethodInvocationCounter</span></span><br><span class="line">  super_class: #<span class="number">43</span>                        <span class="comment">// java/lang/Object</span></span><br><span class="line">  interfaces: <span class="number">0</span>, fields: <span class="number">2</span>, methods: <span class="number">7</span>, attributes: <span class="number">3</span></span><br><span class="line">Constant pool:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    #<span class="number">5</span> = Methodref          #<span class="number">41.</span>#<span class="number">92</span>       <span class="comment">// org/apache/dubbo/common/DeprecatedMethodInvocationCounter.hasThisMethodInvoked:(Ljava/lang/String;)Z</span></span><br><span class="line">    #<span class="number">6</span> = Fieldref           #<span class="number">41.</span>#<span class="number">93</span>       <span class="comment">// org/apache/dubbo/common/DeprecatedMethodInvocationCounter.LOGGER:Lorg/apache/dubbo/common/logger/ErrorTypeAwareLogger;</span></span><br><span class="line">    #<span class="number">7</span> = Class              #<span class="number">94</span>           <span class="comment">// org/apache/dubbo/common/constants/DeprecatedMethodInvocationCounterConstants</span></span><br><span class="line">    #<span class="number">8</span> = String             #<span class="number">95</span>           <span class="comment">// 0-99</span></span><br><span class="line">    #<span class="number">9</span> = String             #<span class="number">96</span>           <span class="comment">// invocation of deprecated method</span></span><br><span class="line">   #<span class="number">10</span> = String             #<span class="number">97</span>           <span class="comment">//</span></span><br><span class="line">   #<span class="number">11</span> = Class              #<span class="number">98</span>           <span class="comment">// java/lang/StringBuilder</span></span><br><span class="line">   #<span class="number">12</span> = Methodref          #<span class="number">11.</span>#<span class="number">88</span>       <span class="comment">// java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">13</span> = String             #<span class="number">99</span>           <span class="comment">// Deprecated method invoked. The method is</span></span><br><span class="line">   #<span class="number">14</span> = Methodref          #<span class="number">11.</span>#<span class="number">100</span>      <span class="comment">// java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">   #<span class="number">15</span> = Methodref          #<span class="number">11.</span>#<span class="number">101</span>      <span class="comment">// java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class="line">   #<span class="number">16</span> = InterfaceMethodref #<span class="number">102.</span>#<span class="number">103</span>     <span class="comment">// org/apache/dubbo/common/logger/ErrorTypeAwareLogger.warn:(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">        </span><br><span class="line">   #<span class="number">102</span> = Class              #<span class="number">144</span>          <span class="comment">// org/apache/dubbo/common/logger/ErrorTypeAwareLogger</span></span><br><span class="line">   #<span class="number">103</span> = NameAndType        #<span class="number">145</span>:#<span class="number">146</span>     <span class="comment">// warn:(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V</span></span><br><span class="line">       </span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">       </span><br><span class="line">   #<span class="number">144</span> = Utf8               org/apache/dubbo/common/logger/ErrorTypeAwareLogger</span><br><span class="line">   #<span class="number">145</span> = Utf8               warn</span><br><span class="line">   #<span class="number">146</span> = Utf8               (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V</span><br><span class="line">       </span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">       </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">onDeprecatedMethodCalled</span><span class="params">(java.lang.String)</span>;</span><br><span class="line">    descriptor: (Ljava/lang/String;)V</span><br><span class="line">    flags: (<span class="number">0x0009</span>) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">6</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokestatic  #<span class="number">5</span>                  <span class="comment">// Method hasThisMethodInvoked:(Ljava/lang/String;)Z</span></span><br><span class="line">         <span class="number">4</span>: ifne          <span class="number">40</span></span><br><span class="line">         <span class="number">7</span>: getstatic     #<span class="number">6</span>                  <span class="comment">// Field LOGGER:Lorg/apache/dubbo/common/logger/ErrorTypeAwareLogger;</span></span><br><span class="line">        <span class="number">10</span>: ldc           #<span class="number">8</span>                  <span class="comment">// String 0-99</span></span><br><span class="line">        <span class="number">12</span>: ldc           #<span class="number">9</span>                  <span class="comment">// String invocation of deprecated method</span></span><br><span class="line">        <span class="number">14</span>: ldc           #<span class="number">10</span>                 <span class="comment">// String</span></span><br><span class="line">        <span class="number">16</span>: <span class="keyword">new</span>           #<span class="number">11</span>                 <span class="comment">// class java/lang/StringBuilder</span></span><br><span class="line">        <span class="number">19</span>: dup</span><br><span class="line">        <span class="number">20</span>: invokespecial #<span class="number">12</span>                 <span class="comment">// Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">        <span class="number">23</span>: ldc           #<span class="number">13</span>                 <span class="comment">// String Deprecated method invoked. The method is</span></span><br><span class="line">        <span class="number">25</span>: invokevirtual #<span class="number">14</span>                 <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">        <span class="number">28</span>: aload_0</span><br><span class="line">        <span class="number">29</span>: invokevirtual #<span class="number">14</span>                 <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">        <span class="number">32</span>: invokevirtual #<span class="number">15</span>                 <span class="comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class="line">        <span class="number">35</span>: invokeinterface #<span class="number">16</span>,  <span class="number">5</span>           <span class="comment">// InterfaceMethod org/apache/dubbo/common/logger/ErrorTypeAwareLogger.warn:(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V</span></span><br><span class="line">        <span class="number">40</span>: aload_0</span><br><span class="line">        <span class="number">41</span>: invokestatic  #<span class="number">17</span>                 <span class="comment">// Method increaseInvocationCount:(Ljava/lang/String;)V</span></span><br><span class="line">        <span class="number">44</span>: <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="以常量池为切入点查找"><a href="#以常量池为切入点查找" class="headerlink" title="以常量池为切入点查找"></a>以常量池为切入点查找</h2><p>考虑到错误码 Logger 的接入是以整个类为单位的，我们可以简化成只扫描这个类是否使用了错误码 Logger 类。</p>
<p>据 Java 虚拟机规范 <sup>[2]</sup>：</p>
<blockquote>
<p>Java Virtual Machine instructions do not rely on the run-time layout of classes, interfaces, class instances, or arrays. Instead, instructions refer to symbolic information in the <code>constant_pool</code> table.</p>
</blockquote>
<p>可知常量池盛装了 .class 文件中所有的符号（比如类的引用）等等。</p>
<p>因此我们只需要查询 .class 文件中间的常量池里头是否存在不符合要求的 Logger 类调用即可。</p>
<h3 id="具体思路"><a href="#具体思路" class="headerlink" title="具体思路"></a>具体思路</h3><p>鉴于 Logger 的方法是接口方法，在 JVM 中是使用 <code>invokeinterface</code> 调用的。其接受的常量池的结构体是 <code>InterfaceMethodref</code>。从 JVM 规范可知 <code>InterfaceMethodref</code> 的结构如下 <sup>[3]</sup>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_InterfaceMethodref_info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u2 class_index;</span><br><span class="line">    u2 name_and_type_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>tag</code>是固定值，代表该项常量池项目是接口方法的引用。</li>
<li><code>class_index</code> 是对应着常量池中接口信息的<strong>索引</strong>，它对应着我们要调用方法所在的接口。</li>
<li><code>name_and_type_index</code> 对应着常量池中的 <code>CONSTANT_NameAndType_info</code>  结构的索引，代表方法签名。</li>
</ol>
<p>因此我们只需要确认 .class 文件里头的所有的 <code>CONSTANT_InterfaceMethodref_info</code> 的内容即可。</p>
<h3 id="Javassist-的实现"><a href="#Javassist-的实现" class="headerlink" title="Javassist 的实现"></a>Javassist 的实现</h3><p>我们可以仿照上篇文章的 Javassist 的用法（以下均为<code>org.apache.dubbo.errorcode.extractor.JavassistConstantPoolErrorCodeExtractor#getIllegalLoggerMethodInvocations</code> 这一方法的讲述）<sup>[4]</sup>：</p>
<ol>
<li><p>首先找到 <code>CONSTANT_InterfaceMethodref_info</code> 在 Javassist 中对应的类 <code>javassist.bytecode.InterfaceMethodrefInfo</code></p>
</li>
<li><p>通过反射调用 <code>ConstPool.getItem(int)</code> 获得所有的常量池的内容（详见前一篇文章的 <code>JavassistUtils.getConstPoolItems</code>），并通过 Stream 筛选和 map 出所有的 <code>InterfaceMethodrefInfo</code> 的实例所对应的常量池索引：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Class INTERFACE_METHOD_INFO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        INTERFACE_METHOD_INFO = Class.forName(<span class="string">&quot;javassist.bytecode.InterfaceMethodrefInfo&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;MethodDefinition&gt; <span class="title function_">getIllegalLoggerMethodInvocations</span><span class="params">(String classFilePath)</span> &#123;</span><br><span class="line">    List&lt;Object&gt; constPoolItems = JavassistUtils.getConstPoolItems(classFile.getConstPool());</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; interfaceMethodRefIndices = constPoolItems.stream()</span><br><span class="line">        .filter(x -&gt; x.getClass() == INTERFACE_METHOD_INFO)</span><br><span class="line">        .map(<span class="built_in">this</span>::getIndexFieldInConstPoolItems)</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另附 <code>getIndexFieldInConstPoolItems</code> 和 <code>ReflectUtils.getDeclaredFieldRecursively</code><sup> [5]</sup> 的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了查找出 Javassist 对应的常量池类实例的 index 的 Field，以确定其在常量池的索引。</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getIndexFieldInConstPoolItems</span><span class="params">(Object item)</span> &#123;</span><br><span class="line">    <span class="comment">// 鉴于 index 这个 Field 是在 javassist.bytecode.ConstInfo 中定义的。</span></span><br><span class="line">    <span class="comment">// 此处其实可以使用 javassist.bytecode.ConstInfo 所对应的 Class 对象直接获取。</span></span><br><span class="line">    <span class="comment">// 但是原本的写法是从该类一直向父类找 index 这个 Field。</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">indexField</span> <span class="operator">=</span> ReflectUtils.getDeclaredFieldRecursively(item.getClass(), <span class="string">&quot;index&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) indexField.get(item);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Field <span class="title function_">getDeclaredFieldRecursively</span><span class="params">(Class cls, String name)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 本类找得到么？</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">indexField</span> <span class="operator">=</span> cls.getDeclaredField(name);</span><br><span class="line">        indexField.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> indexField;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">        <span class="comment">// 到头了</span></span><br><span class="line">        <span class="keyword">if</span> (cls == Object.class) &#123;</span><br><span class="line">            <span class="comment">// null 了事。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向上找。</span></span><br><span class="line">        <span class="keyword">return</span> getDeclaredFieldRecursively(cls.getSuperclass(), name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol start="3">
<li><p>遍历第 2 步所得出的索引，通过 Javassist 的常量池 API 回表查找，同时记录该类所有的方法调用信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接上文 getIllegalLoggerMethodInvocations</span></span><br><span class="line"></span><br><span class="line">List&lt;MethodDefinition&gt; methodDefinitions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> index : interfaceMethodRefIndices) &#123;</span><br><span class="line">    <span class="type">ConstPool</span> <span class="variable">cp</span> <span class="operator">=</span> classFile.getConstPool();</span><br><span class="line"></span><br><span class="line">    <span class="type">MethodDefinition</span> <span class="variable">methodDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodDefinition</span>();</span><br><span class="line">    methodDefinition.setClassName(</span><br><span class="line">        <span class="comment">// 确定 invokeinterface 的接口名</span></span><br><span class="line">        cp.getInterfaceMethodrefClassName(index)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    methodDefinition.setMethodName(</span><br><span class="line">        <span class="comment">// 通过常量池索引确定参数名</span></span><br><span class="line">        cp.getUtf8Info(</span><br><span class="line">            <span class="comment">// 获取方法签名名的常量池索引</span></span><br><span class="line">            cp.getNameAndTypeName(</span><br><span class="line">                <span class="comment">// 获取方法签名所在的常量池索引</span></span><br><span class="line">                cp.getInterfaceMethodrefNameAndType(index)</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    methodDefinition.setArguments(</span><br><span class="line">        <span class="comment">// 通过常量池索引确定方法名</span></span><br><span class="line">        cp.getUtf8Info(</span><br><span class="line">            cp.getNameAndTypeDescriptor(</span><br><span class="line">                cp.getInterfaceMethodrefNameAndType(index)</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    methodDefinitions.add(methodDefinition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另提供 MethodDefinition 类供参考（部分内容通过注解省略。源代码并没用 Lombok。）<sup>[6]</sup>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDefinition</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">    <span class="keyword">private</span> String arguments;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>通过比对调用的方法的类和方法签名来确定是否满足需求。鉴于合符要求的错误码 Logger 的 warn 和 error 调用至少要四个参数，所以只需要确定调用那两个方法的参数个数即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接上文 getIllegalLoggerMethodInvocations</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 确定是否是日志类的方法调用</span></span><br><span class="line">Predicate&lt;MethodDefinition&gt; legacyLoggerClass = x -&gt; x.getClassName().equals(<span class="string">&quot;org.apache.dubbo.common.logger.Logger&quot;</span>);</span><br><span class="line">Predicate&lt;MethodDefinition&gt; errorTypeAwareLoggerClass = x -&gt; x.getClassName().equals(<span class="string">&quot;org.apache.dubbo.common.logger.ErrorTypeAwareLogger&quot;</span>);</span><br><span class="line">Predicate&lt;MethodDefinition&gt; loggerClass = legacyLoggerClass.or(errorTypeAwareLoggerClass);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> methodDefinitions.stream()</span><br><span class="line">    .filter(loggerClass)</span><br><span class="line">    <span class="comment">// 确定是否 warn, error</span></span><br><span class="line">    .filter(x -&gt; x.getMethodName().equals(<span class="string">&quot;warn&quot;</span>) || x.getMethodName().equals(<span class="string">&quot;error&quot;</span>))</span><br><span class="line">    <span class="comment">// 若是 warn 和 error 级别则确定参数是否小于四个，如果是则代表没有挂上错误码。</span></span><br><span class="line">    .filter(x -&gt; x.getArguments().split(<span class="string">&quot;;&quot;</span>).length &lt; <span class="number">4</span>)</span><br><span class="line">    .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过返回的值确定哪些类里头调用了没有错误码的 Logger 调用。</p>
</li>
</ol>
<h2 id="以方法调用为切入点查找"><a href="#以方法调用为切入点查找" class="headerlink" title="以方法调用为切入点查找"></a>以方法调用为切入点查找</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>上述通过判定类常量池的做法虽然可以确定哪个类调用了哪些不符合要求的 Logger 方法调用，但是维护者也需要定位到具体是是哪个方法没有调用到合符要求的 Logger 方法。因此在这里需要以方法调用为切入点查找 Logger 调用。</p>
<h3 id="具体思路-1"><a href="#具体思路-1" class="headerlink" title="具体思路"></a>具体思路</h3><h4 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h4><p>首先我们需要遍历所有方法（通过 <code>ClassFile.getMethods()</code>），并确定 .class 文件中每个方法的具体代码的位置。据 JVM 规范 <sup>[7]</sup>，<code>.class</code> 文件中，方法的具体实现是存放到每个方法的属性表中的 Code 属性，所以在 Javassist 中应使用 Class File API 获取每个方法的 Code 属性（即 <code>getCodeAttribute()</code>），因此有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassFile</span> <span class="variable">classFile</span> <span class="operator">=</span> JavassistUtils.openClassFile(<span class="string">&quot;...&quot;</span>);</span><br><span class="line"><span class="type">ConstPool</span> <span class="variable">cp</span> <span class="operator">=</span> classFile.getConstPool();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (MethodInfo methodInfo : classFile.getMethods()) &#123;</span><br><span class="line">    <span class="type">CodeAttribute</span> <span class="variable">codeAttribute</span> <span class="operator">=</span> methodInfo.getCodeAttribute();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (codeAttribute == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 没有具体实现（抽象方法等），跳过。</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拿到 Code 属性之后，遍历每条指令，直到 <code>invokeinterface</code> 出现就开始比对。</p>
<p>那么怎么遍历每条指令呢？</p>
<h4 id="Javassist-的方法的字节码指令的遍历-API"><a href="#Javassist-的方法的字节码指令的遍历-API" class="headerlink" title="Javassist 的方法的字节码指令的遍历 API"></a>Javassist 的方法的字节码指令的遍历 API</h4><p>这个时候我们可以使用 <code>CodeIterator</code> 来遍历每一条字节码，而这个对象可以通过 <code>CodeAttribute.iterator()</code> 获取。</p>
<p>CodeIterator 的用法与迭代器 Iterator 相似（但不是 Iterator 的实现类），都是使用 <code>hasNext</code> 方法确定是否还有字节码，<code>next</code> 方法拿到下一个字节码指令的字节相对于 Code 属性表最开始的指令的偏移量。<code>byteAt</code> 方法可以拿到偏移量所在位置对应的字节。</p>
<blockquote>
<p>题外话：为什么是 Code 表的偏移量？</p>
<p><img src="/2025/03/02/dubbo-eci-2/codeIterator-1.png" alt="Code of creating CodeIterator (R7.3.9)"></p>
<p><img src="/2025/03/02/dubbo-eci-2/codeIterator-2.png" alt="Part of implementation of CodeIterator (R7.3.9)"></p>
<ol>
<li>在 <code>.class</code> 文件中，Code 是方法的属性。</li>
<li>在获取 CodeIterator 的 <code>CodeAttribute.iterator()</code> 中，调用了 CodeIterator 的构造方法，这个构造方法获取了 CodeAttribute 的 <code>info</code> 这一 Field （即 Code 属性表的原始字节码），并赋值给 <code>CodeIterator.byteCode</code> 属性。</li>
<li>通过 byteAt 方法可知它读取了 byteCode 数组，下标是给定的 index，因此可以看出 index 是相对于 Code 表的偏移量，而非相对于字节码文件的偏移量。</li>
</ol>
</blockquote>
<p>在 Javassist 中有一个数组可以用来对应指令名称和指令的字节码的表示，为 <code>Mnemonic.OPCODE</code> 。我们可以用它比对指令的名称。<sup>[8]</sup> （此处也可以通过直接比对具体指令的字节以提高效率。）</p>
<p>鉴于抽象方法没有 Code 属性表 <sup>[7]</sup>，因此需要通过判断排除这类方法以防 NPE。</p>
<p>整合上述思路并用代码表示，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassFile</span> <span class="variable">classFile</span> <span class="operator">=</span> JavassistUtils.openClassFile(<span class="string">&quot;...&quot;</span>);</span><br><span class="line"><span class="type">ConstPool</span> <span class="variable">cp</span> <span class="operator">=</span> classFile.getConstPool();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (MethodInfo methodInfo : classFile.getMethods()) &#123;</span><br><span class="line">    <span class="type">CodeAttribute</span> <span class="variable">codeAttribute</span> <span class="operator">=</span> methodInfo.getCodeAttribute();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (codeAttribute == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 没有具体实现（抽象方法等），跳过。</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">CodeIterator</span> <span class="variable">codeIterator</span> <span class="operator">=</span> codeAttribute.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (codeIterator.hasNext()) &#123;</span><br><span class="line">        <span class="comment">// 获取下一条指令的索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> codeIterator.next();</span><br><span class="line">        <span class="comment">// 确定具体指令</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">op</span> <span class="operator">=</span> codeIterator.byteAt(index);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 此处可以使用</span></span><br><span class="line">        <span class="comment">// op == 185</span></span><br><span class="line">        <span class="comment">// 来提高效率（直接比较它对应的指令字节）</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;invokeinterface&quot;</span>.equals(Mnemonic.OPCODE[op])) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当指令是 invokeinterface，...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Invokeinterface-的具体参数的获得"><a href="#Invokeinterface-的具体参数的获得" class="headerlink" title="Invokeinterface 的具体参数的获得"></a>Invokeinterface 的具体参数的获得</h4><p>为了进一步确定接下来的行为，我们不妨参考下 JVM 规范中 <code>invokeinterface</code> 指令的参数 <sup>[9]</sup>：</p>
<p><img src="/2025/03/02/dubbo-eci-2/invokeinterface_args.png" alt="P525 - Arguments of invokeinterface (R7.3.5)"></p>
<p>不难看出调用的接口方法的方法签名（即 <code>CONSTANT_InterfaceMethodref_info</code>）的常量池索引是 <code>(indexbyte1 &lt;&lt; 8) | indexbyte2</code> 这一表达式的结果。且 indexbyte1 就在 invokeinterface 这一指令的字节码的下一个字节。故有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前略。</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;invokeinterface&quot;</span>.equals(Mnemonic.OPCODE[op])) &#123;</span><br><span class="line">    <span class="comment">// Indexbyte part of invokeinterface opcode.</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">interfaceMethodConstPoolIndex</span> <span class="operator">=</span></span><br><span class="line">        codeIterator.byteAt(index + <span class="number">1</span>) &lt;&lt; <span class="number">8</span> | codeIterator.byteAt(index + <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再依照“以常量池为切入点查找”一节的办法拿到具体方法签名，并通过 <code>MethodInfo.toString()</code> （或者 <code>MethodInfo.getName()</code>  和  <code>MethodInfo.getDescriptor()</code>）获取发起调用的方法的签名，再做好记录，做好记录全部实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassFile</span> <span class="variable">classFile</span> <span class="operator">=</span> JavassistUtils.openClassFile(<span class="string">&quot;...&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">ConstPool</span> <span class="variable">cp</span> <span class="operator">=</span> classFile.getConstPool();</span><br><span class="line"></span><br><span class="line">Map&lt;String, List&lt;MethodDefinition&gt;&gt; methodDefinitions = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (MethodInfo methodInfo : classFile.getMethods()) &#123;</span><br><span class="line">    <span class="type">CodeAttribute</span> <span class="variable">codeAttribute</span> <span class="operator">=</span> methodInfo.getCodeAttribute();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (codeAttribute == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No detailed implementation, just skip!</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">CodeIterator</span> <span class="variable">codeIterator</span> <span class="operator">=</span> codeAttribute.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (codeIterator.hasNext()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> codeIterator.next();</span><br><span class="line">        <span class="type">int</span> <span class="variable">op</span> <span class="operator">=</span> codeIterator.byteAt(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;invokeinterface&quot;</span>.equals(Mnemonic.OPCODE[op])) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// IndexByte part of invokeinterface opcode.</span></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">interfaceMethodConstPoolIndex</span> <span class="operator">=</span></span><br><span class="line">                codeIterator.byteAt(index + <span class="number">1</span>) &lt;&lt; <span class="number">8</span> | codeIterator.byteAt(index + <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">initiateMethodName</span> <span class="operator">=</span> methodInfo.toString();</span><br><span class="line"></span><br><span class="line">            <span class="type">MethodDefinition</span> <span class="variable">methodDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodDefinition</span>();</span><br><span class="line"></span><br><span class="line">            methodDefinition.setClassName(</span><br><span class="line">                cp.getInterfaceMethodrefClassName(interfaceMethodConstPoolIndex)</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            methodDefinition.setMethodName(</span><br><span class="line">                cp.getUtf8Info(</span><br><span class="line">                    cp.getNameAndTypeName(</span><br><span class="line">                        cp.getInterfaceMethodrefNameAndType(interfaceMethodConstPoolIndex)</span><br><span class="line">                    )</span><br><span class="line">                )</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            methodDefinition.setArguments(</span><br><span class="line">                cp.getUtf8Info(</span><br><span class="line">                    cp.getNameAndTypeDescriptor(</span><br><span class="line">                        cp.getInterfaceMethodrefNameAndType(interfaceMethodConstPoolIndex)</span><br><span class="line">                    )</span><br><span class="line">                )</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            methodDefinitions.computeIfAbsent(initiateMethodName, k -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            methodDefinitions.get(initiateMethodName).add(methodDefinition);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于此处的 methodDefinitions：</span></span><br><span class="line"><span class="comment">// Key 是这个 .class 文件中的方法，Value 是这个方法发起的所有调用。</span></span><br></pre></td></tr></table></figure>

<p>若要筛选出不合格的 Logger 方法调用，只需要筛选 methodDefinitions 这一结果，或在遍历方法调用指令之时完成筛选即可。</p>
<p>以上解决了如何获取所有的 Logger 方法的调用的问题。但是，一个新需求到来 —— 确定不合格的 Logger 调用所在的行号。该怎么办呢？还请看下回分解。</p>
<hr>
<p>备注：</p>
<ol>
<li><p>有关环境：</p>
<p>(a) 命令行 Maven 运行于 OpenJDK <del>19</del> （本文初稿时）22（重新整理时）环境下。</p>
<p>(b) 对于 Dubbo 项目 IDEA JDK 配置为基于 OpenJDK 8 的 GraalVM 21.3.1 的 JDK。</p>
<p>(c) 在编写错误码 Logger 调用自动检测程序时，使用的是 OpenJDK 19 版本，但调节了兼容性设置到 JDK 8。</p>
<p>(d) 在 Dubbo CI 运行时使用 Azul OpenJDK 17。</p>
</li>
<li><p>本文写作时的 JDK 的最新版本为 <del>21</del>  （本文初稿时）23（重新整理时），本文所有的有关 JDK 的参考文献均以该版本为参考。</p>
</li>
</ol>
<hr>
<p>引用和参考：</p>
<style>
    small p {
        color : grey;
        line-height : 1em !important;
    }
</style>
<small>

<p>[1] Apache Dubbo Source Code - org.apache.dubbo.common.DeprecatedMethodInvocationCounter</p>
<p><a target="_blank" rel="noopener" href="https://github.com/apache/dubbo/blob/5ae875d951d354a2f2d3316fc08cab406a3e947e/dubbo-common/src/main/java/org/apache/dubbo/common/DeprecatedMethodInvocationCounter.java">https://github.com/apache/dubbo/blob/5ae875d951d354a2f2d3316fc08cab406a3e947e/dubbo-common/src/main/java/org/apache/dubbo/common/DeprecatedMethodInvocationCounter.java</a></p>
<p>[2]  Java Virtual Machine Specification - Chap. 4 - Constant Pool section</p>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se23/html/jvms-4.html#jvms-4.4">https://docs.oracle.com/javase/specs/jvms/se23/html/jvms-4.html#jvms-4.4</a></p>
<p>[3] Java Virtual Machine Specification - Chap. 4 - The ‘CONSTANT_Fieldref_info’, ‘CONSTANT_Methodref_info’, and ‘CONSTANT_InterfaceMethodref_info’ Structures and Static Constraints section</p>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se23/html/jvms-4.html#jvms-4.4.2">https://docs.oracle.com/javase/specs/jvms/se23/html/jvms-4.html#jvms-4.4.2</a></p>
<p>[4] Apache Dubbo Error Code Inspector Source Code (in dubbo-test-tools) - org.apache.dubbo.errorcode.extractor.JavassistConstantPoolErrorCodeExtractor</p>
<p><a target="_blank" rel="noopener" href="https://github.com/apache/dubbo-test-tools/blob/main/dubbo-error-code-inspector/src/main/java/org/apache/dubbo/errorcode/extractor/JavassistConstantPoolErrorCodeExtractor.java">https://github.com/apache/dubbo-test-tools/blob/main/dubbo-error-code-inspector/src/main/java/org/apache/dubbo/errorcode/extractor/JavassistConstantPoolErrorCodeExtractor.java</a></p>
<p>[5] Apache Dubbo Error Code Inspector Source Code (in dubbo-test-tools) - org.apache.dubbo.errorcode.util.ReflectUtils</p>
<p><a target="_blank" rel="noopener" href="https://github.com/apache/dubbo-test-tools/blob/main/dubbo-error-code-inspector/src/main/java/org/apache/dubbo/errorcode/util/ReflectUtils.java">https://github.com/apache/dubbo-test-tools/blob/main/dubbo-error-code-inspector/src/main/java/org/apache/dubbo/errorcode/util/ReflectUtils.java</a></p>
<p>[6] Apache Dubbo Error Code Inspector Source Code (in dubbo-test-tools) - org.apache.dubbo.errorcode.model.MethodDefinition</p>
<p><a target="_blank" rel="noopener" href="https://github.com/apache/dubbo-test-tools/blob/main/dubbo-error-code-inspector/src/main/java/org/apache/dubbo/errorcode/model/MethodDefinition.java">https://github.com/apache/dubbo-test-tools/blob/main/dubbo-error-code-inspector/src/main/java/org/apache/dubbo/errorcode/model/MethodDefinition.java</a></p>
<p>[7] Java Virtual Machine Specification - Chap. 4 - The Code Attribute section</p>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se23/html/jvms-4.html#jvms-4.7.3">https://docs.oracle.com/javase/specs/jvms/se23/html/jvms-4.html#jvms-4.7.3</a></p>
<p>[8] Javassist API Docs - javassist.bytecode.Mnemonic</p>
<p><a target="_blank" rel="noopener" href="https://www.javassist.org/html/javassist/bytecode/Mnemonic.html">https://www.javassist.org/html/javassist/bytecode/Mnemonic.html</a></p>
<p>[9] Java Virtual Machine Specification - Chap. 4 - invokeinterface section</p>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se23/html/jvms-4.html#jvms-4.10.1.9.invokeinterface">https://docs.oracle.com/javase/specs/jvms/se23/html/jvms-4.html#jvms-4.10.1.9.invokeinterface</a> (Page 525 in the PDF version.)</p>
</small>

<hr />

<p>[ TART - Dubbo (ECI) - T3 - R5,6,7 ] (Mainly @FB (M))</p>
<p>(SNa - ECI, SNu - 2)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://win120a.github.io/2025/03/02/dubbo-eci-2/" data-id="cmebc0jwk0001nl6s70g63kho" data-title="Dubbo 在 CI 中自动检查错误码 Logger 调用的实现（二） - 通过 Javassist 完成 Logger 类的判断" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Apache-Dubbo/" rel="tag">Apache Dubbo</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Dubbo-ECI/" rel="tag">Dubbo ECI</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Javap/" rel="tag">Javap</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Javassist/" rel="tag">Javassist</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2023/05/19/dubbo-eci-1/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">Dubbo 在 CI 中自动检查错误码 Logger 调用的实现（一） - 背景和错误码的获取</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Apache-Dubbo/" rel="tag">Apache Dubbo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dubbo-ECI/" rel="tag">Dubbo ECI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Javap/" rel="tag">Javap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Javassist/" rel="tag">Javassist</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OpenJDK-%E5%BA%95%E5%B1%82%E6%8E%A2%E7%A9%B6/" rel="tag">OpenJDK 底层探究</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tomcat-%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/" rel="tag">Tomcat 原理探究</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Apache-Dubbo/" style="font-size: 20px;">Apache Dubbo</a> <a href="/tags/Dubbo-ECI/" style="font-size: 20px;">Dubbo ECI</a> <a href="/tags/Javap/" style="font-size: 10px;">Javap</a> <a href="/tags/Javassist/" style="font-size: 20px;">Javassist</a> <a href="/tags/OpenJDK-%E5%BA%95%E5%B1%82%E6%8E%A2%E7%A9%B6/" style="font-size: 10px;">OpenJDK 底层探究</a> <a href="/tags/Tomcat-%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/" style="font-size: 10px;">Tomcat 原理探究</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/03/">三月 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">五月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/03/02/dubbo-eci-2/">Dubbo 在 CI 中自动检查错误码 Logger 调用的实现（二） - 通过 Javassist 完成 Logger 类的判断</a>
          </li>
        
          <li>
            <a href="/2023/05/19/dubbo-eci-1/">Dubbo 在 CI 中自动检查错误码 Logger 调用的实现（一） - 背景和错误码的获取</a>
          </li>
        
          <li>
            <a href="/2021/01/27/what-happened-on-annotations/">源码探索 | 从 Java 层面分析注解 (Annotation) 从编译到运行时发生了什么</a>
          </li>
        
          <li>
            <a href="/2020/06/09/tomcat-jndi/">Tomcat 下通过 JNDI 获取绑定的数据源对象的背后原理</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner" style="display: flex;justify-content: space-between; align-items: center;">
      <div>
          
          &copy; 2025 Andy Cheung<br>
          Powered by <a href="https://hexo.io/" target="_blank">Hexo</a><br />
          Published with <a target="_blank" rel="noopener" href="https://pages.github.com">GitHub Pages</a><br />
          Banner image by km30192002 (Licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by/2.0/deed.en">CC-BY 2.0</a>)
      </div>
      <div style="text-align: center">
          <img src="/images/wechat_mp.jpg" style="width: 5rem; height: 5rem; ">
          <div>微信公众号：内核实验室</div>
      </div>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>